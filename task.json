{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "hMIq9t_Fulek",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "a7364105dce8d63d68941fc8b471bd22",
     "grade": false,
     "grade_id": "title",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "\n",
    "This is programming assignment for week 1. In this assignment you will be working with scikit-learn to perform exploratory data analysis and practice working with text data. \n",
    "\n",
    "Please, read all the notebook carefully and make sure that you understand not only the task, but the whole pipeline.\n",
    "\n",
    "### Grading\n",
    "The assignment is automatically graded. \n",
    "\n",
    "**Automatic grading**\n",
    "After you finish solving all the tasks restart the kernel (`kernel -> restart`) and click the button `Validate` to check that everything works as expected. Afterwards, you can submit your work.\n",
    "\n",
    "\n",
    "# Table of Contents:\n",
    "* [Problem 1.](#part1)  Exploratory data analysis\n",
    "     - [Task 1](#task1) [1 pt]\n",
    "     - [Task 2](#task2) [2 pts]\n",
    "     - [Task 3](#task3) [2 pts]\n",
    "     - [Task 4](#task4) [1 pt]\n",
    "     - [Task 5](#task5) [1 pts]\n",
    "     - [Task 6](#task6) [2 pts]\n",
    "     - [Task 7](#task7) [1 pts]\n",
    "   \n",
    "* [Problem 2](#problem2). Text data analysis\n",
    "    - [Task 1](#task2_1) [2 pts]\n",
    "    - [Task 2](#task2_2) [1 pts]\n",
    "    - [Task 3](#task2_3) [1 pts]\n",
    "    - [Task 4](#task2_4) [1 pts]\n",
    "\n",
    "\n",
    "---\n",
    "## Problem 1. Exploratory data analysis <a class=\"anchor\" id=\"part1\"></a>\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "gXOaeCBWOXB5",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "85c046a2445fc77a0301bb0635f1d576",
     "grade": false,
     "grade_id": "cell-88a28302797f3f68",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from sklearn.base import BaseEstimator\n",
    "from sklearn.model_selection import GridSearchCV, train_test_split, cross_val_score\n",
    "from sklearn.preprocessing import StandardScaler, PolynomialFeatures \n",
    "from sklearn.preprocessing import OneHotEncoder, OrdinalEncoder\n",
    "from sklearn.compose import ColumnTransformer\n",
    "from sklearn.linear_model import LinearRegression, Ridge, Lasso, ElasticNet\n",
    "from sklearn.neighbors import  KNeighborsRegressor\n",
    "from sklearn.pipeline import Pipeline, make_pipeline\n",
    "from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score\n",
    "\n",
    "import os"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "GQ9reAhAYSfT",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "1e7f30f9927b94ad1b41285badb34bbc",
     "grade": false,
     "grade_id": "cell-5147a29d38c034d0",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "0vzRNFiurO6X",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "bbaf4208556b7edcfaad51b7decac2a7",
     "grade": false,
     "grade_id": "cell-421725e4973aa676",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "In this task we will go through standard exploratory data analysis and preprocessing steps as well as use them to prepare a dataset and train a predictive model.\n",
    "\n",
    "Let's take a look at the data. We will analyze a dataset of diamond characterics, such as size, color and clarity, in order to train a model to predict it's price.\n",
    "\n",
    "<!-- The data used in this task is slighly preprocessed open dataset from kaggle.com https://www.kaggle.com/shivam2503/diamonds  -->\n",
    "\n",
    "First, we need to exclude the target variable, `price`, and split the dataset into train and test sets. We will use the former to perform all the data analysis steps and train the model, and the latter - to assess the model prediction quality on new data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 195
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 1930,
     "status": "ok",
     "timestamp": 1607626702573,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "KdlG4LxYVqmT",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "8ca2222755e91ed2186b5b41d5f00593",
     "grade": false,
     "grade_id": "cell-52b3a70201c21899",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "e37e6158-c658-4228-a30f-14144bfa79ea"
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>carat</th>\n",
       "      <th>cut</th>\n",
       "      <th>color</th>\n",
       "      <th>clarity</th>\n",
       "      <th>depth</th>\n",
       "      <th>table</th>\n",
       "      <th>price</th>\n",
       "      <th>x</th>\n",
       "      <th>y</th>\n",
       "      <th>z</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0.23</td>\n",
       "      <td>Ideal</td>\n",
       "      <td>E</td>\n",
       "      <td>SI2</td>\n",
       "      <td>61.5</td>\n",
       "      <td>55.0</td>\n",
       "      <td>326</td>\n",
       "      <td>3.95</td>\n",
       "      <td>3.98</td>\n",
       "      <td>2.43</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0.21</td>\n",
       "      <td>Premium</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>59.8</td>\n",
       "      <td>61.0</td>\n",
       "      <td>326</td>\n",
       "      <td>3.89</td>\n",
       "      <td>3.84</td>\n",
       "      <td>2.31</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>0.23</td>\n",
       "      <td>Good</td>\n",
       "      <td>E</td>\n",
       "      <td>VS1</td>\n",
       "      <td>56.9</td>\n",
       "      <td>NaN</td>\n",
       "      <td>327</td>\n",
       "      <td>4.05</td>\n",
       "      <td>4.07</td>\n",
       "      <td>2.31</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>0.29</td>\n",
       "      <td>Premium</td>\n",
       "      <td>I</td>\n",
       "      <td>VS2</td>\n",
       "      <td>62.4</td>\n",
       "      <td>58.0</td>\n",
       "      <td>334</td>\n",
       "      <td>4.20</td>\n",
       "      <td>4.23</td>\n",
       "      <td>2.63</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>0.31</td>\n",
       "      <td>Good</td>\n",
       "      <td>J</td>\n",
       "      <td>SI2</td>\n",
       "      <td>63.3</td>\n",
       "      <td>58.0</td>\n",
       "      <td>335</td>\n",
       "      <td>4.34</td>\n",
       "      <td>4.35</td>\n",
       "      <td>2.75</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   carat      cut color clarity  depth  table  price     x     y     z\n",
       "1   0.23    Ideal     E     SI2   61.5   55.0    326  3.95  3.98  2.43\n",
       "2   0.21  Premium   NaN     NaN   59.8   61.0    326  3.89  3.84  2.31\n",
       "3   0.23     Good     E     VS1   56.9    NaN    327  4.05  4.07  2.31\n",
       "4   0.29  Premium     I     VS2   62.4   58.0    334  4.20  4.23  2.63\n",
       "5   0.31     Good     J     SI2   63.3   58.0    335  4.34  4.35  2.75"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "file_path = \"diamonds_prep.csv\"\n",
    "df = pd.read_csv(file_path, index_col=0)\n",
    "df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "GEkiURROPcrB",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "75a46dda094fc17ccff44ceb5bc5350d",
     "grade": false,
     "grade_id": "cell-82dd190d122fcd4c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "y = df[\"price\"]\n",
    "X = df.drop(\"price\", axis=1)\n",
    "\n",
    "X_tr, X_te, y_tr, y_te = train_test_split(X, y, test_size=0.3, random_state=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "OyIYOGktWHsn",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "f55e9e113a9c69d63c7be4afad452479",
     "grade": false,
     "grade_id": "cell-5f20df0ca542d0ab",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "This dataset contains both numerical and categorical characteristics. The latter ones take string values, each of which means a certain category. Most standard machine learning algorithms are able to work only with numerical variables, and categorical data have to be additionally prepared before model training. \n",
    "\n",
    "<!-- Also, most of the models usually cannot handle missing values in the data, so we need to check if there are any in our dataset. -->\n",
    "\n",
    "<!-- However, first we will need to check if there are any **missing values** in the data and properly handle them.  -->"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 1049,
     "status": "ok",
     "timestamp": 1607626704085,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "IRFFmv-5VQpR",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "b18096b9c36320d15b1386cdc44919d1",
     "grade": false,
     "grade_id": "cell-2d7b5ab032248c4f",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "99c243de-a35c-4f98-c15c-0feac520f3e6"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Types of variables presented in the training data:\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "carat      float64\n",
       "cut         object\n",
       "color       object\n",
       "clarity     object\n",
       "depth      float64\n",
       "table      float64\n",
       "x          float64\n",
       "y          float64\n",
       "z          float64\n",
       "dtype: object"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"Types of variables presented in the training data:\\n\")\n",
    "X_tr.dtypes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 793
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 1938,
     "status": "ok",
     "timestamp": 1607626705181,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "X6y1RzACYP95",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "3df32e086c89dd0d0006eff6490b04f3",
     "grade": false,
     "grade_id": "cell-0876d0e36ccb8419",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "8bae3eae-5b70-4f4a-d115-72caba1cf767"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of numerical features = 6 \n",
      "\n",
      "Distribution of numerical features:\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1080x720 with 6 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "num_cols = X_tr.columns[(X_tr.dtypes == \"int64\") |(X_tr.dtypes == \"float64\")].tolist() #\n",
    "print(\"Number of numerical features =\", len(num_cols), \"\\n\")\n",
    "\n",
    "print(\"Distribution of numerical features:\")\n",
    "X_tr[num_cols].hist(bins=20, grid=True, figsize=(15, 10), layout=(2, 3))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "37ad9a63762f64ea4298e21e8542ec95",
     "grade": false,
     "grade_id": "cell-d4e379677c14714b",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of missing values in each column:\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "carat    1915\n",
       "depth    1913\n",
       "table    3784\n",
       "x        1854\n",
       "y        1875\n",
       "z        1885\n",
       "dtype: int64"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"Number of missing values in each column:\\n\")\n",
    "X_tr[num_cols].isnull().sum()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 411
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 1082,
     "status": "ok",
     "timestamp": 1607626707336,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "2E06nhQV3yQe",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "47f5ac4d7bc0cfec1a096a71ccb9e402",
     "grade": false,
     "grade_id": "cell-66cb8656f2877f5e",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "a8da2406-7127-41ed-c7e0-a62f7bd166d4"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of categorical features = 3 \n",
      "\n",
      "Distribution of categorical features:\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1080x360 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "cat_cols = X_tr.columns[X_tr.dtypes == \"object\"].tolist() #\n",
    "print(\"Number of categorical features =\", len(cat_cols), \"\\n\")\n",
    "\n",
    "print(\"Distribution of categorical features:\")\n",
    "plt.figure(figsize=(15, 5))\n",
    "for i, col in enumerate(cat_cols):\n",
    "    plt.subplot(1, 3, i + 1)\n",
    "    X_tr[col].value_counts(normalize=True).plot.pie(autopct=lambda x: f\"{round(x, 2)}%\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "eaf3037f93a59efdc46c8fc3c945ca23",
     "grade": false,
     "grade_id": "cell-d1fa642d6113136c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of missing values in each column:\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "cut        1912\n",
       "color      3724\n",
       "clarity    1793\n",
       "dtype: int64"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"Number of missing values in each column:\\n\")\n",
    "X_tr[cat_cols].isnull().sum() "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "5lDSZvIWW2z4",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "83c0b8e39be5651b10a7b2f4b45840f4",
     "grade": false,
     "grade_id": "cell-221451761606d6cf",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Missing values\n",
    "\n",
    "<!-- [Missing values recap] - missing values may occir / appear in the data for various reasons. -->\n",
    "\n",
    "Most of the classical models are unable to handle missing values. Thus, we need to remove them from the data or fill with some value.\n",
    "\n",
    "There exist various strategies to deal with missing values. If some column or row lacks a significant part of the data, it may be reasonable to completely drop it. However, in most cases, this leads to significant information loss. Instead, missing values can be filled with some constant (such as 0 or an empty string), or a statistic of the corresponding feature (such as mean, median, or mode). When filling missing values, one may also create an additional feature that indicates whether the value was present in the original data. This can be informative because sometimes the absence of a feature value can be a feature in itself.\n",
    "\n",
    "\n",
    "<!-- Однако в большинстве случаев это приводит к значительной потере информации. Вместо этого, пропущенные значения могут быть заполнены некоторой константой, например нулем или пустой строкой, или статистикой по соответствующему признаку (например, средним, медианой или модой). При заполнении пропущенных значений, может быть также полезно создавать дополнительный признак-индикатор, указывающий, имелось ли это значение в изначальных данных. Так как иногда отсутствие значения само по себе может являться признаком. -->\n",
    "\n",
    "<!-- - (the most simple) just remove the feature that contains missing values and / or objects that have many empty fiels,\n",
    "- fill missing values with some constant value, for example, 0, -1 or an empty string\n",
    "- fill missing values with some statistic of the feature (mean, median, mode, etc)\n",
    "- ... -->"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "KJ1A4hVqX9em",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "c4a39da99f90fb3612b23c08f295f11f",
     "grade": false,
     "grade_id": "cell-c31cb9e7c7658e67",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "\n",
    "---\n",
    "**Task 1.1** [1 pt]  <a class=\"anchor\" id=\"task1\"></a>\n",
    "\n",
    "Write a function that removes objects from the dataset, if they have more than **50%** of missing values.\n",
    "- Use pandas `isnull()` method to find missing (NaN) values. See example above.\n",
    "- Compute number of missing values in each row. Use argument `axis` to specify the dimention of summation. \n",
    "- From both the object matrix `X` and the target variable `y`, select a subset of rows with **at most 50%** of missing values.\n",
    "- See [this pandas tutorial](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#boolean-indexing) if you struggle to implement this task."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "deletable": false,
    "id": "FyaDreYvWVwk",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "bcd200f643492e0a164037f027aac9d0",
     "grade": false,
     "grade_id": "cell-6d8dfb21a0185f75",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "def drop_uninformative_objects(X, y):\n",
    "    # your code here\n",
    "    merged_df = pd.concat([X_tr, y_tr], axis=1, join=\"inner\")\n",
    "    total_columns = (len(merged_df.columns)-1)*0.5\n",
    "    filterd_df =merged_df[merged_df.apply(lambda i: i.isnull().sum()<=total_columns, axis = 1)] \n",
    "    X_subset = filterd_df[['carat', 'cut','color','clarity','depth','table', 'x','y','z']]\n",
    "    y_subset = filterd_df[['price']]\n",
    "    return X_subset, y_subset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(       carat        cut color clarity  depth  table     x     y     z\n",
       " 30084   0.32      Ideal     I    VVS2    NaN   56.0  4.42  4.40  2.71\n",
       " 21865   1.54    Premium     F     SI1   62.8   58.0  7.35  7.32  4.61\n",
       " 3762    0.71      Ideal     F     VS1   62.1    NaN  5.69  5.75  3.55\n",
       " 21263   1.03      Ideal     F    VVS2   62.0   56.0  6.48  6.45  4.01\n",
       " 15461   1.33      Ideal     J     NaN   62.4   55.0  7.02  7.05  4.39\n",
       " ...      ...        ...   ...     ...    ...    ...   ...   ...   ...\n",
       " 50058   0.70  Very Good     I     VS2   62.8   59.0  5.56   NaN  3.51\n",
       " 32512   0.40       Good     E     SI2   63.9   57.0  4.71  4.65  2.99\n",
       " 5193    0.91  Very Good     G     VS2   62.7   63.0  6.05  6.00  3.78\n",
       " 12173   1.18      Ideal   NaN     VS1   61.7   56.0  6.79  6.82  4.20\n",
       " 33004   0.32      Ideal     E    VVS1   60.9   56.0  4.41  4.43  2.69\n",
       " \n",
       " [37756 rows x 9 columns],\n",
       "        price\n",
       " 30084    720\n",
       " 21865   9926\n",
       " 3762    3457\n",
       " 21263   9413\n",
       " 15461   6190\n",
       " ...      ...\n",
       " 50058   2202\n",
       " 32512    798\n",
       " 5193    3776\n",
       " 12173   5182\n",
       " 33004    813\n",
       " \n",
       " [37756 rows x 1 columns])"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "drop_uninformative_objects(X_tr, y_tr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "2w48l163XfKA",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "e8e18b295aab3431a2037b4e82c93c3a",
     "grade": true,
     "grade_id": "cell-979228e097fcc15e",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# TEST drop_uninformative_objects function\n",
    "A = pd.DataFrame(np.array([\n",
    "    [0, 3, np.nan],\n",
    "    [4, np.nan, np.nan],\n",
    "    [np.nan, 6, 7],\n",
    "    [np.nan, np.nan, np.nan],\n",
    "    [5, 5, 5],\n",
    "    [np.nan, 8, np.nan],\n",
    "]))\n",
    "b = pd.Series(np.arange(6))\n",
    "A_subset, b_subset = drop_uninformative_objects(A, b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "yf3BYsH11CkW",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "1b06f207ac154ac7520bd99b86db8e2f",
     "grade": false,
     "grade_id": "cell-880acd9fa0c54f24",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "Now, we can use this function to drop rows with too many missing values from the training dataset. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "hlW1fThA1NJ8",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "a7006dbc1be1c7aab8b925b1b6b63784",
     "grade": false,
     "grade_id": "cell-8fa260291b829ac8",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "X_tr, y_tr = drop_uninformative_objects(X_tr, y_tr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "MN4iLoAG1U0s",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "2d4f985742ac61db06866dc7df0c39c1",
     "grade": false,
     "grade_id": "cell-3014d9843873ca75",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "For categorical features, let's basically fill missing values with a constant value - an \"Unknown\" string."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "PRx5qUP51T24",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "922fc9f68c83aeb16919331c729ab905",
     "grade": false,
     "grade_id": "cell-836f59811bf6c15f",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "X_tr[cat_cols] = X_tr[cat_cols].fillna(\"Unknown\")\n",
    "X_te[cat_cols] = X_te[cat_cols].fillna(\"Unknown\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "brmXt9gnavYO",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "cf492ee39a91ecd9e97b0534d2952898",
     "grade": false,
     "grade_id": "cell-2d5298936e2bfc9f",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "\n",
    "---\n",
    "**Task 1.2** [2 pts]  <a class=\"anchor\" id=\"task2\"></a>\n",
    "\n",
    "For numerical features, impelement a class that fills missing values in each feature with its mean value.\n",
    "\n",
    "- Implement a `fit` method that takes as input feature matrix `X` and computes and saves **mean** value of each feature (assuming that all the features are numerical). The feature matrix can be either `pd.DataFrame`, or `np.ndarray`.\n",
    "- Implement a `transform` method that takes as input feature matrix `X` and replaces NaN values in each feature with a corresponding mean value and returns a transformed feature matrix. \n",
    "\n",
    "<!-- Note, that `fit` method also takes target variable `y` as argument. It is needed for compatibility with other ML staff, however, in this class target variable will not be used, and you can just leave it equal to `None`. -->\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "deletable": false,
    "id": "EAKkPXn7XMEO",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "3bae20da5eeb2357a387ec672d838ddb",
     "grade": false,
     "grade_id": "cell-197464a29b5d7c45",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.base import TransformerMixin, BaseEstimator\n",
    "\n",
    "class MeanImputer(BaseEstimator, TransformerMixin): \n",
    "    def fit(self, X, y=None):\n",
    "        \"\"\"\n",
    "        Compute and save mean value of each feature in the feature matrix.\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        X : pd.DataFrame or numpy.ndarray of shape (n_samples, n_features)\n",
    "            Feature matrix.\n",
    "        y : pd.Series or numpy.ndarray of shape (n_samples,) (default : None)\n",
    "            Target values. Optional.\n",
    "        \n",
    "        Returns\n",
    "        -------\n",
    "        self : returns an instance of self.\n",
    "        \"\"\"\n",
    "        self.column_mean = []\n",
    "        for i in range(X.shape[1]):\n",
    "            if type(X) is not np.ndarray:\n",
    "                X_i = X.values[:, i]\n",
    "            else:\n",
    "                X_i = X[:, i]\n",
    "            \n",
    "            gg=[n for n in X_i if not pd.isna(n)]\n",
    "            average_gg = sum(gg)/len(gg)\n",
    "            self.column_mean.append(average_gg)   \n",
    "            # calculate mean for each column and add to the list `self.column_mean`\n",
    "            # your code here\n",
    "        \n",
    "            \n",
    "        return self\n",
    "    \n",
    "    def transform(self, X):\n",
    "        \"\"\"\n",
    "        Fills missing values in each feature with a corresponding mean value.\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        X : pd.DataFrame or numpy.ndarray of shape (n_samples, n_features)\n",
    "            Feature matrix.\n",
    "        \n",
    "        Returns\n",
    "        -------\n",
    "        X_transformed : array-like of shape (n_samples, n_features)\n",
    "            Transformed feature matrix. \n",
    "        \"\"\"\n",
    "\n",
    "        X_transformed = []\n",
    "        for i in range(len(self.column_mean)):\n",
    "            if type(X) is not np.ndarray:\n",
    "                X_i = X.values[:, i]\n",
    "            else:\n",
    "                X_i = X[:, i]\n",
    "                \n",
    "            \n",
    "            # Fill missing values using mean values \n",
    "            # your code here\n",
    "            for e, ii in enumerate(X_i):\n",
    "                if pd.isna(ii):\n",
    "                    X_i[e] = self.column_mean[i]\n",
    "            X_transformed.append(X_i)\n",
    "        \n",
    "        X_transformed = np.column_stack(X_transformed)\n",
    "        return X_transformed"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 7.0, 5.5]\n",
      "37756\n",
      "37756\n"
     ]
    }
   ],
   "source": [
    "A = np.array([\n",
    "    [0, np.nan, 4],\n",
    "    [np.nan, 6, 7],\n",
    "    [np.nan, 8, np.nan],\n",
    "])\n",
    "mean_imp = MeanImputer()\n",
    "mean_imp.fit(A)\n",
    "print(mean_imp.column_mean)\n",
    "print(len(mean_imp.transform(X_tr)))\n",
    "print(len(X_tr))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "w7kCQG5Jwf82",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "58bf56289071162d410a78ee817c57f8",
     "grade": true,
     "grade_id": "cell-475729f5ca0dd035",
     "locked": true,
     "points": 2,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 7.0, 5.0]\n"
     ]
    }
   ],
   "source": [
    "# TEST MeanImputer class\n",
    "A = np.array([\n",
    "    [0, np.nan, 3],\n",
    "    [np.nan, 6, 7],\n",
    "    [np.nan, 8, np.nan],\n",
    "])\n",
    "mean_imp = MeanImputer()\n",
    "mean_imp.fit(A)\n",
    "print(mean_imp.column_mean)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "9DYQPUz8EG2t",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "6cf89bd227ed85037eab154de71d90c1",
     "grade": false,
     "grade_id": "cell-ca38bf936be8c65d",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Numerical features\n",
    "\n",
    "From the histograms of numerical variables, you can also see that different features have different value ranges. However, many machine learning models, in particular linear models and kNN algorithm, are sensitive to feature scales. Therefore, it is a good practice to scale all the numeric variables to the same range before training.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "ghgohzq7XBLa",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "b9c6a77793d29e05765e9174911b0c55",
     "grade": false,
     "grade_id": "cell-9c03b67ed70742bc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "\n",
    "---\n",
    "**Task 1.3** [2 pts]  <a class=\"anchor\" id=\"task3\"></a>\n",
    "\n",
    "For numerical features, impelement a class that normalizes each feature values by subtracting the mean and dividing by the standard deviation.\n",
    "\n",
    "- Implement a `fit` method that takes as input feature matrix `X` and computes and saves **mean** and **std** values of each feature (assuming that all the features are numerical). The feature matrix can be either `pd.DataFrame`, or `np.ndarray`.\n",
    "- Implement a `transform` method that takes as input feature matrix `X` and normalizes each column using precomputed mean and std values for this feature. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "deletable": false,
    "id": "H0-vXGv6Vc0c",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "dff6a4accc5a2e552a3a0564125d983d",
     "grade": false,
     "grade_id": "cell-e06a079c48b613eb",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.base import TransformerMixin, BaseEstimator\n",
    "\n",
    "class Scaler(BaseEstimator, TransformerMixin):\n",
    "    def fit(self, X, y=None):\n",
    "        \"\"\"\n",
    "        Compute and save mean and standard deviation values \n",
    "        of each feature in the feature matrix.\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        X : pd.DataFrame or numpy.ndarray of shape (n_samples, n_features)\n",
    "            Feature matrix.\n",
    "        y : pd.Series or numpy.ndarray of shape (n_samples,) (default : None)\n",
    "            Target values. Optional.\n",
    "        \n",
    "        Returns\n",
    "        -------\n",
    "        self : returns an instance of self.\n",
    "        \"\"\"\n",
    "        self.column_mean = []\n",
    "        self.column_std = []\n",
    "        for i in range(X.shape[1]):\n",
    "            # extract column values \n",
    "            if type(X) is not np.ndarray:\n",
    "                X_i = X.values[:, i]\n",
    "            else:\n",
    "                X_i = X[:, i]\n",
    "                \n",
    "            ff=[n for n in X_i if not pd.isna(n)]\n",
    "            average_ff = sum(ff)/len(ff)\n",
    "            self.column_mean.append(average_ff)  \n",
    "            #print(type(X_i))\n",
    "            #X_i_array = np.ndarray(X_i)\n",
    "            #print(X_i_array)\n",
    "            #print(X_i)\n",
    "            self.column_std.append(X_i.std())\n",
    "            # compute mean and std\n",
    "            # your code here\n",
    "            \n",
    "        return self\n",
    "    \n",
    "    def transform(self, X):\n",
    "        \"\"\"\n",
    "        Normalizes values of each feature \n",
    "        by subtructing the corresponding precomputed feature mean \n",
    "        and dividing by the corresponding standard deviation.\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        X : pd.DataFrame or numpy.ndarray of shape (n_samples, n_features)\n",
    "            Feature matrix.\n",
    "        \n",
    "        Returns\n",
    "        -------\n",
    "        X_transformed : array-like of shape (n_samples, n_features)\n",
    "            Transformed feature matrix. \n",
    "        \"\"\"   \n",
    "        X_transformed = []\n",
    "        \n",
    "        for i in range(len(self.column_mean)):\n",
    "            # extract column values \n",
    "            if type(X) is not np.ndarray:\n",
    "                X_i = X.values[:, i]\n",
    "            else:\n",
    "                X_i = X[:, i]\n",
    "                \n",
    "            # your code here\n",
    "            for e, ii in enumerate(X_i):\n",
    "                X_i[e] = (ii-self.column_mean[i])/self.column_std[i]\n",
    "            X_transformed.append(X_i)\n",
    "            \n",
    "        X_transformed = np.column_stack(X_transformed)\n",
    "        return X_transformed"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "Rt1uBpln7bhq",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "2ab47249d3f6fd2fbaddaa0ac51e8bd1",
     "grade": true,
     "grade_id": "cell-34a318dd0934c18e",
     "locked": true,
     "points": 2,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Scaler()"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# TEST Scaler class\n",
    "A = np.arange(9).reshape(3, 3)\n",
    "scaler = Scaler()\n",
    "scaler.fit(A)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-1, -1, -1],\n",
       "       [ 0,  0,  0],\n",
       "       [ 1,  1,  1]])"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "scaler.column_std\n",
    "scaler.transform(A)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "UqCmMJmAFL5J",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "3d730bf5bebe05dfc0cd4e31419fb356",
     "grade": false,
     "grade_id": "cell-fc3e9de0b5f5f60f",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    " ### Model training and validation\n",
    "\n",
    "Now, we will train and evaluate the first regression model for diamond price prediction using only the numerical features. We will use **k-nearest neighbors** algorithm to build the model, and mean absolute error metric to evaluate its predictive performance. \n",
    "\n",
    "It is important that for correct and fair training, the test set should not be used at any stage of model building. Therefore, statistics for feature preprocessing have to be estimated only on the training sample. For example, the mean and standard deviation of each column should be computed on the training set and then used to normalize the features in both the training and test sets.\n",
    "\n",
    "`Sklearn` contains ready-to-use feature transformer classes, with the `fit` method to estimate parameters on the training set and the `transform` method to actually apply the transformation to training and test sets. `MeanImputer` and `Scaler` classes, that you have implemented previously, are also compatible with other sklearn transformers.\n",
    "\n",
    "There also exist several tools to combine transformers and estimators into a single pipeline:\n",
    "- `ColumnTransformer`\n",
    "- `Pipeline`\n",
    "- `make_pipeline`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "VTlqz02ohdH6",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "fe3f39e578663e2f61def81b20fb80ae",
     "grade": false,
     "grade_id": "cell-2d220bdb23396161",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# define transformations for numerical columns using MeanImputer and Scaler\n",
    "num_transformers_pipe = make_pipeline(\n",
    "    MeanImputer(),\n",
    "    Scaler(),\n",
    ")\n",
    "\n",
    "# defien column transformer (we drop non-numerical features)\n",
    "col_transformer = ColumnTransformer([\n",
    "    (\"num_col_transformer\", num_transformers_pipe, num_cols),\n",
    "], remainder='drop')\n",
    "\n",
    "\n",
    "# define a Pipeline with 2 steps: 1. transform columns; 2. Apply the model\n",
    "model = Pipeline([\n",
    "    (\"col_transformer\", col_transformer),\n",
    "    (\"estimator\", KNeighborsRegressor())\n",
    "]\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "FlVc8ZgdxxC2"
   },
   "source": [
    "\n",
    "---\n",
    "**Task 1.4** [1 pt]  <a class=\"anchor\" id=\"task4\"></a>\n",
    "\n",
    "Implement a function to evaluate performance of a given model both on the train and test sets. The function should\n",
    "- take as input a model (possibly a pipeline), as well as feature matrix and target variable for both train and test sets,\n",
    "- fit the model on the train set,\n",
    "- compute model predictions for train and test sets,\n",
    "- assess the quality of both predictions with mean absolute error (MAE) metric,\n",
    "- return train and test MAE scores."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "deletable": false,
    "id": "Vj6GGiGlZmyE",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "6fd47f2e6cb915394e289233b9d373b5",
     "grade": false,
     "grade_id": "cell-3b2863b8ca643ff7",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.metrics import mean_absolute_error\n",
    "\n",
    "def evaluate_model(model, X_tr, y_tr, X_te, y_te):\n",
    "    # your code here\n",
    "    model.fit(X_tr, y_tr)\n",
    "    #model.fit(X_te, y_te)\n",
    "    y_pred_te = model.predict(X_te)\n",
    "    y_pred_tr = model.predict(X_tr)\n",
    "    mae_te = mean_absolute_error(y_pred_te, y_te)\n",
    "    mae_tr = mean_absolute_error(y_pred_tr, y_tr)\n",
    "    \n",
    "    \n",
    "    return mae_tr, mae_te"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 782.2],\n",
       "       [7651. ],\n",
       "       [3130.4],\n",
       "       ...,\n",
       "       [ 755.6],\n",
       "       [ 690.2],\n",
       "       [6117.4]])"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "model1 = Pipeline([\n",
    "    (\"col_transformer\", col_transformer),\n",
    "    (\"estimator\", KNeighborsRegressor())\n",
    "]\n",
    ")\n",
    "\n",
    "model1.fit(X_tr, y_tr)\n",
    "model1.predict(X_te)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Index(['carat', 'cut', 'color', 'clarity', 'depth', 'table', 'x', 'y', 'z'], dtype='object')"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "X_tr.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "b6bd4b78dcc725f4300ca67f8bf08df4",
     "grade": false,
     "grade_id": "cell-6e6bda66a036866a",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "Evaluate performance of the model based on numerical features only:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "mOGOgRqMzxfq",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "012be6765187e9d1036c8cebfabeb72f",
     "grade": true,
     "grade_id": "cell-681232043cba68a4",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# TEST evaluate_model function\n",
    "mae_tr, mae_te = evaluate_model(model, X_tr, y_tr, X_te, y_te)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "GytsZtgCz3nc",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "1a8ef7952185183b555c6a4f911413ee",
     "grade": false,
     "grade_id": "cell-1aa7dd77ca19a40c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train MAE = 684.51\n",
      "Test MAE = 833.24\n"
     ]
    }
   ],
   "source": [
    "models_scores = {}\n",
    "models_scores[\"num only\"] = {\"train\" : mae_tr, \"test\" : mae_te}\n",
    "print(\"Train MAE = %.2f\" % mae_tr)\n",
    "print(\"Test MAE = %.2f\" % mae_te)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "bNxGoLt_9ufB"
   },
   "source": [
    "### Categorical features\n",
    "\n",
    "<!-- [categorical features recap?] -->\n",
    "\n",
    "Most of the machine learning models cannot work with categorical features directly in their original form. However, there are several ways to represent them in an alternative form (encode). We will consider and compare two options for encoding categorical features - **one-hot encoding** and **mean target encoding**.\n",
    "\n",
    "Ohe-hot-encoding is one of the most popular and straight-forward ways. In this case each categorical feature is replaced by a set of binary features for each category. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "XsB7Qg9xDnZ8"
   },
   "source": [
    "`Sklearn` has ready-to-use implementation of OneHotEncoder transformer (as well as many other transformers). \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 407
    },
    "executionInfo": {
     "elapsed": 660,
     "status": "ok",
     "timestamp": 1607627239273,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "wa_lzhVZ19a8",
    "outputId": "911c3e26-a674-42e3-fdc3-67bece89697b"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Categorical variable before one-hot encoding:\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>cut</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>30084</th>\n",
       "      <td>Ideal</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21865</th>\n",
       "      <td>Premium</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3762</th>\n",
       "      <td>Ideal</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21263</th>\n",
       "      <td>Ideal</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>15461</th>\n",
       "      <td>Ideal</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "           cut\n",
       "30084    Ideal\n",
       "21865  Premium\n",
       "3762     Ideal\n",
       "21263    Ideal\n",
       "15461    Ideal"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Categorical variable after one-hot encoding:\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead tr th {\n",
       "        text-align: left;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr>\n",
       "      <th></th>\n",
       "      <th>Fair</th>\n",
       "      <th>Good</th>\n",
       "      <th>Ideal</th>\n",
       "      <th>Premium</th>\n",
       "      <th>Unknown</th>\n",
       "      <th>Very Good</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>30084</th>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21865</th>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3762</th>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21263</th>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>15461</th>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      Fair Good Ideal Premium Unknown Very Good\n",
       "30084  0.0  0.0   1.0     0.0     0.0       0.0\n",
       "21865  0.0  0.0   0.0     1.0     0.0       0.0\n",
       "3762   0.0  0.0   1.0     0.0     0.0       0.0\n",
       "21263  0.0  0.0   1.0     0.0     0.0       0.0\n",
       "15461  0.0  0.0   1.0     0.0     0.0       0.0"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "print(\"Categorical variable before one-hot encoding:\")\n",
    "display(X_tr[[\"cut\"]].head())\n",
    "\n",
    "print(\"Categorical variable after one-hot encoding:\")\n",
    "ohenc = OneHotEncoder(sparse=False)\n",
    "ohenc.fit_transform(X_tr[[\"cut\"]])\n",
    "display(pd.DataFrame(ohenc.fit_transform(X_tr[[\"cut\"]]), \n",
    "                     index=X_tr.index, columns=ohenc.categories_).head())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "3f02ca58e3db8f6da1476fa38d717793",
     "grade": false,
     "grade_id": "cell-56fa2e7770c46be2",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "**Task 1.5** [1 pts]  <a class=\"anchor\" id=\"task5\"></a>\n",
    "\n",
    "Let us create a 2-step pipeline:\n",
    "\n",
    "1. Column Transformer, which\n",
    "    - Apply one-hot encoding to categorical feature\n",
    "    - Apply `num_transformers_pipe` (defined above) to numerical feature\n",
    "2. A regression model\n",
    "\n",
    "Please, finish the definition of the `col_transformer`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "deletable": false,
    "id": "MDnEd4SOh85b",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "6d21ea222367a99d6ee6501fbdbc5d0f",
     "grade": false,
     "grade_id": "cell-e0f59c3b9570aa2f",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "\n",
    "col_transformer = ColumnTransformer([\n",
    "    # your code here\n",
    "    ('ohe', OneHotEncoder(), ['cut','color','clarity']),\n",
    "    ('numeric', num_transformers_pipe, num_cols)\n",
    "    \n",
    "    \n",
    "], remainder='drop')\n",
    "\n",
    " \n",
    "\n",
    "model = Pipeline(steps = [\n",
    "    (\"col_transformer\", col_transformer),\n",
    "    (\"estimator\", KNeighborsRegressor())\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 15584,
     "status": "ok",
     "timestamp": 1607627263188,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "rqI9PU_Qh85b",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "450b0d13c9541c5a7cc6b0c9c0900c93",
     "grade": true,
     "grade_id": "cell-936346eac885f257",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "f5333293-db33-4e27-8eed-dd996982ae93"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train MAE = 428.26\n",
      "Test MAE = 526.21\n"
     ]
    }
   ],
   "source": [
    "\n",
    "mae_tr, mae_te = evaluate_model(model, X_tr, y_tr, X_te, y_te)\n",
    "models_scores[\"num & cat (one-hot)\"] = {\"train\" : mae_tr, \"test\" : mae_te}\n",
    "print(\"Train MAE = %.2f\" % mae_tr)\n",
    "print(\"Test MAE = %.2f\" % mae_te)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "TZt6bhT-X9en",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "344718b63194e077f3455e10229ed0cc",
     "grade": false,
     "grade_id": "cell-105edfbad47a5ceb",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Mean target encoding"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "eTWuCDxtdVH1"
   },
   "source": [
    "Another way to encode categorical variables in **mean target encoding**. The idea behind the approach is that each of the categories is replaced by the average value of the target variable for objects from that category. Thus, the categorical feature can be encoded with a single numerical vector.\n",
    "\n",
    "<!-- [overfirtting and adding noise to the target variable] -->\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "hmfJGLDsLzny"
   },
   "source": [
    "---\n",
    "**Task 1.6** [2 pts]  <a class=\"anchor\" id=\"task6\"></a>\n",
    "\n",
    "Implement mean target encoding transformer. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {
    "deletable": false,
    "id": "gW1XwoL3O8zu",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "ed906ce2bf5d0a768875d29b5088729d",
     "grade": false,
     "grade_id": "cell-9ca2a5792628cf4a",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "from sklearn.base import TransformerMixin, BaseEstimator\n",
    "\n",
    "class MeanTargetEncoder(BaseEstimator, TransformerMixin):\n",
    "    \"\"\"\n",
    "    Encode categorical features as a numerical vector \n",
    "    of mean target values for each category.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    noise_level : float, default=0.01\n",
    "        The variance of Gaussian noise to be added to the target variable \n",
    "        before computing the mean. Larger values lead to less accurate \n",
    "        mean values for categories but prevent overfitting.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, \n",
    "                 noise_level=0.01):\n",
    "        self.noise_level = noise_level\n",
    "    \n",
    "    def fit(self, X, y):\n",
    "        \"\"\"\"\n",
    "        For each feature in the feature matrix, \n",
    "        compute and save mean target value for each category. \n",
    "        \n",
    "        All the values are stored in the dictionary `self.column_category_mean`\n",
    "        Keys - column names. Values - dictionary with unique categories and corresponding means\n",
    "        \n",
    "        Example for 2 categorical features: `district`, `city_type`  \n",
    "        self.column_category_mean = {\n",
    "                                    'distric': {'central': 2000, \n",
    "                                                 'south': 1000, \n",
    "                                                 'north': 1500},\n",
    "                                    'city_type': {'capital': 2100,\n",
    "                                                  'small city': 1700,\n",
    "                                                  'village': 1200}\n",
    "                                      }\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        X : pd.DataFrame or numpy.ndarray of shape (n_samples, n_features)\n",
    "            Feature matrix.\n",
    "        y : pd.Series or numpy.ndarray of shape (n_samples,) (default : None)\n",
    "            Target values.\n",
    "        Returns\n",
    "        -------\n",
    "        self : returns an instance of self.\n",
    "        \"\"\"\n",
    "        \n",
    "        # get target and add noise to it\n",
    "        if type(y) is not np.ndarray:\n",
    "            target = y.values.copy()\n",
    "        else:\n",
    "            target = y.copy()\n",
    "        if self.noise_level > 0:\n",
    "            noise = np.random.randn(target.size) * (self.noise_level * target.std())\n",
    "            target = target + noise\n",
    "\n",
    "\n",
    "        self.column_category_mean = {}\n",
    "        \n",
    "        for i in range(X.shape[1]):\n",
    "            # get column name (`col`) and the values (`X_i`)\n",
    "            if type(X) is not np.ndarray:\n",
    "                col = X.columns[i]\n",
    "                X_i = X[col].values\n",
    "            else:\n",
    "                col = i\n",
    "                X_i = X[:, col]\n",
    "                \n",
    "            # your code here\n",
    "            t = pd.DataFrame({col: X_i, 'prices': target})\n",
    "            self.column_category_mean[col] = t.groupby([col]).mean().to_dict()['prices']\n",
    "        \n",
    "            \n",
    "    \n",
    "        return self\n",
    "    \n",
    "    def transform(self, X):\n",
    "        \"\"\"\n",
    "        For each feature in the feature matrix,\n",
    "        replaces each category with a corresponding precomuted \n",
    "        mean target value.\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        X : pd.DataFrame or numpy.ndarray of shape (n_samples, n_features)\n",
    "            Feature matrix.\n",
    "        \n",
    "        Returns\n",
    "        -------\n",
    "        X_transformed : array-like of shape (n_samples, n_features)\n",
    "            Transformed feature matrix. \n",
    "        \"\"\"\n",
    "\n",
    "        X_transformed = []\n",
    "        for col in self.column_category_mean:\n",
    "            # extract column values \n",
    "            if type(X) is not np.ndarray:\n",
    "                X_i = X[col].values\n",
    "            else:\n",
    "                X_i = X[:, col]\n",
    "                \n",
    "            # encode categories of X_i using `self.column_category_mean`. And append the result to `X_transformed`\n",
    "            # your code here\n",
    "            district_means = []\n",
    "            for e, ii in enumerate(X_i):\n",
    "                ans = self.column_category_mean[col][X_i[e]]\n",
    "                district_means.append(ans)\n",
    "            X_transformed.append(district_means)\n",
    "\n",
    "                \n",
    "        X_transformed = np.column_stack(X_transformed)\n",
    "        return X_transformed"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "fOrYsWbrnevP",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "44a7ccbbaa57e0221e2feed1d21b8945",
     "grade": true,
     "grade_id": "cell-5b7539f99c11a112",
     "locked": true,
     "points": 2,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>district</th>\n",
       "      <th>city_type</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>2000.0</td>\n",
       "      <td>1500.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2300.0</td>\n",
       "      <td>1500.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>2000.0</td>\n",
       "      <td>1966.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>2300.0</td>\n",
       "      <td>2450.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>1450.0</td>\n",
       "      <td>1966.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>1450.0</td>\n",
       "      <td>1966.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>2300.0</td>\n",
       "      <td>2450.000000</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   district    city_type\n",
       "0    2000.0  1500.000000\n",
       "1    2300.0  1500.000000\n",
       "2    2000.0  1966.666667\n",
       "3    2300.0  2450.000000\n",
       "4    1450.0  1966.666667\n",
       "5    1450.0  1966.666667\n",
       "6    2300.0  2450.000000"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# TEST MeanTargetEncoder\n",
    "\n",
    "# toy dataset\n",
    "dist = ['south', 'central', 'south','central','north','north','central']\n",
    "city = ['small city', 'small city', 'capital', 'village', 'capital', 'capital', 'village']\n",
    "price = np.array([1000, 2000, 3000, 2800, 1200, 1700, 2100])\n",
    "X = pd.DataFrame({'district':dist, 'city_type': city})\n",
    "\n",
    "# mean target encoder\n",
    "enc = MeanTargetEncoder(noise_level=0.)\n",
    "enc.fit(X, price)\n",
    "X_encoded = pd.DataFrame(enc.transform(X), columns = X.columns)\n",
    "display(X_encoded)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'district': {'central': 2300.924188847213,\n",
       "  'north': 1449.908824631178,\n",
       "  'south': 1997.7066514175392}}"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y = price\n",
    "if type(y) is not np.ndarray:\n",
    "    target = y.values.copy()\n",
    "else:\n",
    "    target = y.copy()\n",
    "if 0.01 > 0:\n",
    "    noise = np.random.randn(target.size) * (0.01 * target.std())\n",
    "    target = target + noise\n",
    "\n",
    "    \n",
    "    \n",
    "# for i in range(X.shape[1]):\n",
    "#     # get column name (`col`) and the values (`X_i`)\n",
    "#     if type(X) is not np.ndarray:\n",
    "#         col = X.columns[i]\n",
    "#         X_i = X[col].values\n",
    "#     else:\n",
    "#         col = i\n",
    "#         X_i = X[:, col]\n",
    "\n",
    "res = {}\n",
    "i = 0\n",
    "if type(X) is not np.ndarray:\n",
    "    col = X.columns[i]\n",
    "    X_i = X[col].values\n",
    "else:\n",
    "    col = i\n",
    "    X_i = X[:, col]\n",
    "t = pd.DataFrame({col: X_i, 'prices': target})\n",
    "res[col] = t.groupby([col]).mean().to_dict()['prices']\n",
    "res\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "i"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "id": "PHJ_QB9MOLSJ"
   },
   "outputs": [],
   "source": [
    "# use Mean Target encoder instead of OHE\n",
    "cat_mean_target_enc = make_pipeline(\n",
    "    MeanTargetEncoder(noise_level=0.01),\n",
    "    StandardScaler(),\n",
    ")\n",
    "\n",
    "col_transformer = ColumnTransformer([\n",
    "    (\"num_col_transformer\", num_transformers_pipe, num_cols),\n",
    "    (\"cat_mean_target\", cat_mean_target_enc, cat_cols),\n",
    "], remainder='drop')\n",
    "\n",
    "\n",
    "model = Pipeline([\n",
    "    (\"col_transformer\", col_transformer),\n",
    "    (\"estimator\", KNeighborsRegressor())\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 3694,
     "status": "ok",
     "timestamp": 1607627346071,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "XY944ZsuOLUr",
    "outputId": "b3e38b9c-44fb-4d19-9161-26935507cd20"
   },
   "outputs": [],
   "source": [
    "# mae_tr, mae_te = evaluate_model(model, X_tr, y_tr, X_te, y_te)\n",
    "# models_scores[\"num & cat (mean target)\"] = {\"train\" : mae_tr, \"test\" : mae_te}\n",
    "# print(\"Train MAE = %.2f\" % mae_tr)\n",
    "# print(\"Test MAE = %.2f\" % mae_te)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "51bv9frfj8r7"
   },
   "source": [
    "\n",
    "### Ordinal categorical variables\n",
    "\n",
    "In some cases, categorical variables may have ordinal values. For example, in our data, the attribute \"cut\" has values Fair, Good, Very Good, Premium, and Ideal. We can assume that these values are \"ordered\" and encode them with the numbers 1, 2, 3, 4 and 5 respectively. Thus, 1 means \"worst\" value (Fair) and 5 means \"best\" (Ideal) and 0 can be used to encode \"Unknown\" (missing) values. \n",
    "This can provide additional information to the model and improve quality, especially for linear models.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 745,
     "status": "ok",
     "timestamp": 1607628029759,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "oga5ppKgUXbN",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "2e327db3e284a6930209a8a2ea2bea3c",
     "grade": false,
     "grade_id": "cell-64315b20a5d33b2b",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "1952b71d-dec7-4760-9279-c2d137e2d2e8"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['color', 'clarity'] ['cut']\n"
     ]
    }
   ],
   "source": [
    "# separate columns with ordinal features from other categorical features\n",
    "ord_cols = [\"cut\"]\n",
    "cat_cols = list(set(cat_cols) - set(ord_cols))\n",
    "print(cat_cols, ord_cols)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "N6CHoFTwTw5Y",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "cee4612c68dc2b8790e6715fcbb2d9ee",
     "grade": false,
     "grade_id": "cell-cc95e138609d2b62",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# create lists of categories for each ordinal feature\n",
    "# (categories should be ordered from minimal to maximal)\n",
    "ord_col_categories = [[\n",
    "    \"Unknown\",\n",
    "    \"Fair\",\n",
    "    \"Good\",\n",
    "    \"Very Good\",\n",
    "    \"Premium\",\n",
    "    \"Ideal\",          \n",
    "]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "D91_HQC-VVHv",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "caf7e2dd160b65b3970f58f95ebfde5e",
     "grade": false,
     "grade_id": "cell-2e276550a6ac19e2",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# defien ordinal encoder\n",
    "ord_enc = make_pipeline(\n",
    "    OrdinalEncoder(categories=ord_col_categories),\n",
    "    StandardScaler(),\n",
    ")\n",
    "\n",
    "# combine all column transforms\n",
    "col_transformer = ColumnTransformer(transformers = [\n",
    "    (\"num_col_transformer\", num_transformers_pipe, num_cols),\n",
    "    (\"cat_one_hot\",  OneHotEncoder(handle_unknown=\"ignore\"), cat_cols),\n",
    "    (\"ord_enc\", ord_enc, ord_cols)\n",
    "], remainder='drop')\n",
    "\n",
    "\n",
    "model = Pipeline(steps = [\n",
    "    (\"col_transformer\", col_transformer),\n",
    "    (\"estimator\", KNeighborsRegressor())\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 12131,
     "status": "ok",
     "timestamp": 1607628367275,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "ONau_qTiV03g",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "f5d19b26cb3f97c70a824ef8a9f85dd5",
     "grade": false,
     "grade_id": "cell-6f46b5edf13966c8",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "e304db04-6a23-416f-d244-43a95683ef0a"
   },
   "outputs": [],
   "source": [
    "# evaluate model performance\n",
    "mae_tr, mae_te = evaluate_model(model, X_tr, y_tr, X_te, y_te)\n",
    "models_scores[\"num, cat & ord\"] = {\"train\" : mae_tr, \"test\" : mae_te}\n",
    "print(\"Train MAE = %.2f\" % mae_tr)\n",
    "print(\"Test MAE = %.2f\" % mae_te)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "YfKK-MVBmVcw"
   },
   "source": [
    "\n",
    "### Feature engineering\n",
    "\n",
    "We can also use the original features to derive new, more complex or informative features on their basis. \n",
    "\n",
    "For example, in our data we have three features \"x\", \"y\" and \"z\" and can assume that they correspond to measurements of the diamond size along three axes. In this case, product of these three features, that is, the approximate volume, can also be a useful feature for predicting the value of a diamond.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 195
    },
    "deletable": false,
    "editable": false,
    "executionInfo": {
     "elapsed": 665,
     "status": "ok",
     "timestamp": 1607628375659,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "Rf469JT_WkBT",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "09ab8377a5080512c8166b45c49eea79",
     "grade": false,
     "grade_id": "cell-f832e432b56fb3b4",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "outputId": "15659c24-9a68-4f85-f251-9874b35c9d44"
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>carat</th>\n",
       "      <th>cut</th>\n",
       "      <th>color</th>\n",
       "      <th>clarity</th>\n",
       "      <th>depth</th>\n",
       "      <th>table</th>\n",
       "      <th>x</th>\n",
       "      <th>y</th>\n",
       "      <th>z</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>30084</th>\n",
       "      <td>0.32</td>\n",
       "      <td>Ideal</td>\n",
       "      <td>I</td>\n",
       "      <td>VVS2</td>\n",
       "      <td>NaN</td>\n",
       "      <td>56.0</td>\n",
       "      <td>4.42</td>\n",
       "      <td>4.40</td>\n",
       "      <td>2.71</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21865</th>\n",
       "      <td>1.54</td>\n",
       "      <td>Premium</td>\n",
       "      <td>F</td>\n",
       "      <td>SI1</td>\n",
       "      <td>62.8</td>\n",
       "      <td>58.0</td>\n",
       "      <td>7.35</td>\n",
       "      <td>7.32</td>\n",
       "      <td>4.61</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3762</th>\n",
       "      <td>0.71</td>\n",
       "      <td>Ideal</td>\n",
       "      <td>F</td>\n",
       "      <td>VS1</td>\n",
       "      <td>62.1</td>\n",
       "      <td>NaN</td>\n",
       "      <td>5.69</td>\n",
       "      <td>5.75</td>\n",
       "      <td>3.55</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21263</th>\n",
       "      <td>1.03</td>\n",
       "      <td>Ideal</td>\n",
       "      <td>F</td>\n",
       "      <td>VVS2</td>\n",
       "      <td>62.0</td>\n",
       "      <td>56.0</td>\n",
       "      <td>6.48</td>\n",
       "      <td>6.45</td>\n",
       "      <td>4.01</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>15461</th>\n",
       "      <td>1.33</td>\n",
       "      <td>Ideal</td>\n",
       "      <td>J</td>\n",
       "      <td>Unknown</td>\n",
       "      <td>62.4</td>\n",
       "      <td>55.0</td>\n",
       "      <td>7.02</td>\n",
       "      <td>7.05</td>\n",
       "      <td>4.39</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "       carat      cut color  clarity  depth  table     x     y     z\n",
       "30084   0.32    Ideal     I     VVS2    NaN   56.0  4.42  4.40  2.71\n",
       "21865   1.54  Premium     F      SI1   62.8   58.0  7.35  7.32  4.61\n",
       "3762    0.71    Ideal     F      VS1   62.1    NaN  5.69  5.75  3.55\n",
       "21263   1.03    Ideal     F     VVS2   62.0   56.0  6.48  6.45  4.01\n",
       "15461   1.33    Ideal     J  Unknown   62.4   55.0  7.02  7.05  4.39"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "X_tr.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "1a7f6caa8f8bb7b4f035e1300e669318",
     "grade": false,
     "grade_id": "cell-db8f89c8a7b29fa3",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "---\n",
    "**Task 1.7** [1 pts]  <a class=\"anchor\" id=\"task7\"></a>\n",
    "\n",
    "Add `volume` feature as a product of `x`, `y`, `z` features (to both train and test datasets)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 353
    },
    "deletable": false,
    "executionInfo": {
     "elapsed": 752,
     "status": "ok",
     "timestamp": 1607629310821,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "BV4W-CC_Wp5g",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "5ebcac47e7dca340744fcbc810082ddc",
     "grade": false,
     "grade_id": "cell-fbd57bcfb8f51740",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "outputId": "8f2a7387-ab3e-4a22-fd08-6e1986378988"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'pandas.core.series.Series'>\n"
     ]
    }
   ],
   "source": [
    "# your code here\n",
    "volume_df = X_tr['x']*X_tr['y']*X_tr['z']\n",
    "print(type(volume_df))\n",
    "X_tr['volume']=volume_df.values\n",
    "X_tr\n",
    "volume_df = X_te['x']*X_te['y']*X_te['z']\n",
    "X_te['volume']=volume_df.values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "ba31f2bcca5d839747008c1e462934a5",
     "grade": true,
     "grade_id": "cell-1982ab69808024bc",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Distribution of created features:\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0.5, 1.0, 'Volume on test')"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 720x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "print(\"Distribution of created features:\")\n",
    "fig, ax = plt.subplots(ncols=2, figsize=(10, 4))\n",
    "X_tr[[\"volume\"]].hist(bins=20, grid=True, ax=ax[0])\n",
    "ax[0].set_title('Volume on train')\n",
    "X_te[[\"volume\"]].hist(bins=20, grid=True, ax=ax[1]);\n",
    "ax[0].set_title('Volume on test')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 690,
     "status": "ok",
     "timestamp": 1607629551794,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "OMjiPVlqYBgm",
    "outputId": "ce00c2e9-577a-4167-bb2c-247ad63271f5"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['carat', 'depth', 'table', 'x', 'y', 'z', 'volume']"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# update list of numerical features\n",
    "num_cols = X_tr.columns[np.logical_or(X_tr.dtypes == \"int64\", X_tr.dtypes == \"float64\")].tolist() #\n",
    "num_cols"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {
    "id": "KHoZFnQTYb4L"
   },
   "outputs": [],
   "source": [
    "# define columns transforms (nothing cahnges for ordinal and categorical features, but the list of numerical features was updated)\n",
    "col_transformer = ColumnTransformer(transformers = [\n",
    "    (\"num_col_transformer\", num_transformers_pipe, num_cols),\n",
    "    (\"cat_one_hot\", OneHotEncoder(handle_unknown=\"ignore\"), cat_cols),\n",
    "    (\"ord_enc\", ord_enc, ord_cols)\n",
    "], remainder='drop')\n",
    "\n",
    "model = Pipeline(steps = [\n",
    "    (\"col_transformer\", col_transformer),\n",
    "    (\"estimator\", KNeighborsRegressor())\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 12592,
     "status": "ok",
     "timestamp": 1607629564589,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "Rm6N9GCgYnmt",
    "outputId": "9326b371-1d8b-4a7b-f9c8-2c2f1e0073c9"
   },
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-56-f744e0b70f9e>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;31m# evaluate model performance\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m \u001b[0mmae_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmae_te\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mevaluate_model\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmodel\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_te\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_te\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      3\u001b[0m \u001b[0mmodels_scores\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"num, cat & ord + engineering\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m\"train\"\u001b[0m \u001b[0;34m:\u001b[0m \u001b[0mmae_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"test\"\u001b[0m \u001b[0;34m:\u001b[0m \u001b[0mmae_te\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Train MAE = %.2f\"\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mmae_tr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Test MAE = %.2f\"\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mmae_te\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-22-0fbbab906bd0>\u001b[0m in \u001b[0;36mevaluate_model\u001b[0;34m(model, X_tr, y_tr, X_te, y_te)\u001b[0m\n\u001b[1;32m      6\u001b[0m     \u001b[0;31m#model.fit(X_te, y_te)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      7\u001b[0m     \u001b[0my_pred_te\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpredict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_te\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 8\u001b[0;31m     \u001b[0my_pred_tr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpredict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_tr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      9\u001b[0m     \u001b[0mmae_te\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmean_absolute_error\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my_pred_te\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_te\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     10\u001b[0m     \u001b[0mmae_tr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmean_absolute_error\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my_pred_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_tr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/sklearn/utils/metaestimators.py\u001b[0m in \u001b[0;36m<lambda>\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    114\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    115\u001b[0m         \u001b[0;31m# lambda, but not partial, allows help() to work with update_wrapper\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 116\u001b[0;31m         \u001b[0mout\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mlambda\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mobj\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    117\u001b[0m         \u001b[0;31m# update the docstring of the returned function\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    118\u001b[0m         \u001b[0mupdate_wrapper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mout\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfn\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/sklearn/pipeline.py\u001b[0m in \u001b[0;36mpredict\u001b[0;34m(self, X, **predict_params)\u001b[0m\n\u001b[1;32m    418\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0m_\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtransform\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_iter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mwith_final\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    419\u001b[0m             \u001b[0mXt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtransform\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtransform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mXt\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 420\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msteps\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpredict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mXt\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mpredict_params\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    421\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    422\u001b[0m     \u001b[0;34m@\u001b[0m\u001b[0mif_delegate_has_method\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdelegate\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'_final_estimator'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/sklearn/neighbors/_regression.py\u001b[0m in \u001b[0;36mpredict\u001b[0;34m(self, X)\u001b[0m\n\u001b[1;32m    172\u001b[0m         \u001b[0mX\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcheck_array\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maccept_sparse\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'csr'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    173\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 174\u001b[0;31m         \u001b[0mneigh_dist\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mneigh_ind\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mkneighbors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    175\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    176\u001b[0m         \u001b[0mweights\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_get_weights\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mneigh_dist\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mweights\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/sklearn/neighbors/_base.py\u001b[0m in \u001b[0;36mkneighbors\u001b[0;34m(self, X, n_neighbors, return_distance)\u001b[0m\n\u001b[1;32m    662\u001b[0m                 delayed_query(\n\u001b[1;32m    663\u001b[0m                     self._tree, X[s], n_neighbors, return_distance)\n\u001b[0;32m--> 664\u001b[0;31m                 \u001b[0;32mfor\u001b[0m \u001b[0ms\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mgen_even_slices\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mn_jobs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    665\u001b[0m             )\n\u001b[1;32m    666\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/joblib/parallel.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self, iterable)\u001b[0m\n\u001b[1;32m   1002\u001b[0m             \u001b[0;31m# remaining jobs.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1003\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_iterating\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1004\u001b[0;31m             \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdispatch_one_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0miterator\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1005\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_iterating\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_original_iterator\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1006\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/joblib/parallel.py\u001b[0m in \u001b[0;36mdispatch_one_batch\u001b[0;34m(self, iterator)\u001b[0m\n\u001b[1;32m    833\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    834\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 835\u001b[0;31m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_dispatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtasks\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    836\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    837\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/joblib/parallel.py\u001b[0m in \u001b[0;36m_dispatch\u001b[0;34m(self, batch)\u001b[0m\n\u001b[1;32m    752\u001b[0m         \u001b[0;32mwith\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_lock\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    753\u001b[0m             \u001b[0mjob_idx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_jobs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 754\u001b[0;31m             \u001b[0mjob\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_backend\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mapply_async\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbatch\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcallback\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mcb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    755\u001b[0m             \u001b[0;31m# A job can complete so quickly than its callback is\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    756\u001b[0m             \u001b[0;31m# called before we get here, causing self._jobs to\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/joblib/_parallel_backends.py\u001b[0m in \u001b[0;36mapply_async\u001b[0;34m(self, func, callback)\u001b[0m\n\u001b[1;32m    207\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mapply_async\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcallback\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    208\u001b[0m         \u001b[0;34m\"\"\"Schedule a func to be run\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 209\u001b[0;31m         \u001b[0mresult\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mImmediateResult\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfunc\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    210\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mcallback\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    211\u001b[0m             \u001b[0mcallback\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mresult\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/joblib/_parallel_backends.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, batch)\u001b[0m\n\u001b[1;32m    588\u001b[0m         \u001b[0;31m# Don't delay the application, to avoid keeping the input\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    589\u001b[0m         \u001b[0;31m# arguments in memory\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 590\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mresults\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mbatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    591\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    592\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mget\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/joblib/parallel.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    254\u001b[0m         \u001b[0;32mwith\u001b[0m \u001b[0mparallel_backend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_backend\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mn_jobs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_n_jobs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    255\u001b[0m             return [func(*args, **kwargs)\n\u001b[0;32m--> 256\u001b[0;31m                     for func, args, kwargs in self.items]\n\u001b[0m\u001b[1;32m    257\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    258\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m__len__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/joblib/parallel.py\u001b[0m in \u001b[0;36m<listcomp>\u001b[0;34m(.0)\u001b[0m\n\u001b[1;32m    254\u001b[0m         \u001b[0;32mwith\u001b[0m \u001b[0mparallel_backend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_backend\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mn_jobs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_n_jobs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    255\u001b[0m             return [func(*args, **kwargs)\n\u001b[0;32m--> 256\u001b[0;31m                     for func, args, kwargs in self.items]\n\u001b[0m\u001b[1;32m    257\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    258\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m__len__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/sklearn/neighbors/_base.py\u001b[0m in \u001b[0;36m_tree_query_parallel_helper\u001b[0;34m(tree, *args, **kwargs)\u001b[0m\n\u001b[1;32m    489\u001b[0m     \u001b[0munder\u001b[0m \u001b[0mPyPy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    490\u001b[0m     \"\"\"\n\u001b[0;32m--> 491\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0mtree\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mquery\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    492\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    493\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# evaluate model performance\n",
    "mae_tr, mae_te = evaluate_model(model, X_tr, y_tr, X_te, y_te)\n",
    "models_scores[\"num, cat & ord + engineering\"] = {\"train\" : mae_tr, \"test\" : mae_te}\n",
    "print(\"Train MAE = %.2f\" % mae_tr)\n",
    "print(\"Test MAE = %.2f\" % mae_te)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Ch8dhnW4VCsb"
   },
   "source": [
    "Finally, we may look how model performance on train and test sets have changed depending on the used features."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 427
    },
    "executionInfo": {
     "elapsed": 811,
     "status": "ok",
     "timestamp": 1607631874106,
     "user": {
      "displayName": "Марина Поминова",
      "photoUrl": "",
      "userId": "04196186528550871600"
     },
     "user_tz": -180
    },
    "id": "7-0Y18TrOpDt",
    "outputId": "704067c0-10ad-4874-f787-881d1a1801a3"
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAnwAAAGCCAYAAAB6nR6iAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjEsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+j8jraAAAgAElEQVR4nOzdeXxU9dX48c/JvpJAICHsOyQsAUFUNkGICGpdqghUW1fa57GtWleqda1P+VVrrXVprVptLSCK4oaymooKKEjCEnZBCUtYA4RNSM7vj+8NDDEhE0gyyeS8X6/7InPvnXvP3Lkzc/iuoqoYY4wxxpjgFRLoAIwxxhhjTPWyhM8YY4wxJshZwmeMMcYYE+Qs4TPGGGOMCXKW8BljjDHGBDlL+IwxxhhjgpwlfMb4QUSWi8jDgY6jKohIfxFZKiLfi0hWLYjn2crGISIqIldVU0gGEJGNInJXNRw3RkTeEpG93vvYpqrPYU4QkcbedR4c6FhMYFnCZ6qNiLzqfdGoiBwVke0i8omI3Coi4YGOrx77C5ADtAeuDHAsVcISh9MnIteLSGENnvJGYBAwAEgFNlXFQb3vmw+q4ljGBCNL+Ex1m437Um8DXAi8DzwCzBOR2ADGVZ91AOaq6iZV3R3oYOobEYkIdAwB1gFYqarLVHWbqhYFOqDS7D+kJhhZwmeq2xHvS32zqmar6lPAYOAs4J6SnUQkQkT+n4jkicgBEflKRIb7bB/sleJcIiLZInJYRBaLSG/fk4lIPxH5r4gcFJHNIvKCiDTw2Z4lIs+LyP+JyE6v1PFJEQnx2SdZRN4VkUMi8q2I3Fj6RYlIgoi86D1/v3fOPj7brxeRQhEZ6lUHH/BKN9uWOs7FIrLQO9cuEXlfRKL8uSZlEZFIEXlaRPK9a7RARAZ429qIiAIJwCve9by+nONkedfuTyKyW0R2iMht3vGfE5ECEflORK4r9bzuIjLbez27vVKXBJ/tod713uMtTwOhpY4hInKPiKz3jrNMRK491esu9fxwEXlGRLaIyBER2SQiE06xf4KI/Nt7Lw+LyDcicrvP9gbetdjqbV8pItf4bL/Si7HkXPeLiPhs3ygiD4vIKyJSAPzHW3/Ke7WcWAd598th7z3+s/gkkP7c36WONxj4JxArJ0rjH/bZJUpE/i4i+7z78O4yrl25n4MyzpcF3AYM8s6V5a2v6PMfKiIvi8gG755Y690jId72h4GfARf7vI7BJfd86ZjEp0mAzz5jRGSuiBwCfu5tu0FEcr3rvUZE7pCTvyt+7q0/LO4zMkNEwsp57RXG4j1+UNz3zhER2SYi//LZVuFnQ0TOFvfdeFhElgDnlPd+mHpGVW2xpVoW4FXgg3K2vQcs93n8H2ABrqqnHfBL4Hsgw9s+GFBgFTAc6Aa8CWwDYrx9ugOFwJ1AR9wX3XzgLZ/zZAF7gUeBTsAo4Bgwxmef6cAKoD/Qy3tOIfCwt12Az4APgb64EovHgH1AqrfP9cBRXAlnX6AHsASY4XOei7xz/x5I9/a5y+f1nPKalHNd/wJsBS4G0oB/eLGn4hKrpsAB3I9uUyC6nONkea/nYe9a3uld/4+855a85iNAM+85McBmYJr3XpwPrAGm+hz3Hu/6jwK6AH/1zpPls8/jwGrv+rQFxnoxX+yzjwJXlXrcxvv7Tlw14SCgFdAPuOEU1+yvQLb3PrXB3WtX+7zXnwO5XjztgBHAFd723kARrtS6E/AT73r/yuf4G73XeI933Trix71aRpzNvevwN++9vQR3//+pMvd3qWNGeO/nAe9+aArE+cS9C3ffdQB+5V3n8/z9HJRxvkbAK8AX3rka+fn5D/de09neezQKKABu8rbHAW8As3xeR4S3rwJ9SsVx/P7x2WcjcBXunmsB3IL7LJWsu9S73r/0ntfHu7Y/AVoDGcAdQFg5r92fWH7sXb+Lcfdun5Lz+fPZAGKB7bjvxm6478qV3jkGB/o3wZbALgEPwJbgXTh1wjcBOOj93R4oBlqV2mca8Lz392DvS+snPtvjvC/9m73H/wJeLnWMnt7zkr3HWcD8UvvMAl7y/u7k7d/fZ3tr3I/6w97jC3A/1tGljpMN3OP9fb13nM4+23+C+xEL8R5/Dkwu5/pUeE3KeE6sd/yf+qwLBdYDv/dZVwhcX8F7d9J1wv247wDe81kX7p2v5MfqFlyyEe+zT8n71sF7vAW432d7CC4pzPJ5DYeAgaXieRqY7vP4pISv1L7PAHMA8fM+fQ/4ZznbMr33Ia2c7f/BVY/7rnsYyPN5vBF4v9Q+Fd6rZZzrcWBdyf3jc58d4cR/Ek55f5dz3OuBwjLWbwQmlVq3FnjA389BOed7lpMT/Erf6972CcBsn8evUur7hsolfHeW2uc74LpS624Hcr2/ryx9v1dwn/kTy29wCV14Gc+v8LMBjMN9J8b5bL8WS/hsUaXMomdjaoDgvoTAVe8KkOtTEwYQCcwt9bz5JX+oaqGILMOVjoErbengW93mHRfcj8p27++lpY65BUj2/k7D/fh86XOeb0Vki8/+vXGlWTtKxRvlnafEEVVdXeo84UAisBtXevgqZavMNSnR3jv+5z6xF4nIfE5co8o4fp1UVUVkO7DMZ91REdnDydduqaru9znGF7jrmS4iO3Aljb7vYbGILARaeqvScdfxY3HVzyXCcQmIP17FJTlrRGQmrsT2I1UtLmf/F4C3ROQs73nvq+p/vW29gK2qurKc56bhSrh8fQY8JCINVHWft25RqX38vVdLn2t+qdfxGa4kqwMn3q9T3d+Vdapj+fs5qIhf97qI/AK4GfcfsGjcPfFtJc5TkePvkYg0wd2TfxeRF3z2CePE+zTLO/8GEZkBzATeLnX/V9abuBLXkmN+jPtP1hH8+2yUfAZ9O+HMxxiwhM8ETDrwjfd3CC75OxtXDerrUCWOGQK8BPy5jG2bff4ufQ7lRHtWoWIhQD4wsIxt+3z+PlbGeUqe7885KntNSmLXMraVta4iZV2niq5deefx9/wlx7oUV8JyqnjKPpHq1+J67F6EK4V6DcgRkcyykj5V/UhEWuOqaocCH4rIm6p6AxXfD/6+5gOltvl7r57OuU71HlXWqY7l7+egIhXe615i/DSuycMX3vFvBa6o4Ngl77dvm8ryOmT4vkclr/EX3vl+QFX3e/9JGIQrCR4P/J+InK2qW8p4SoWxqOomEemMuw+HAX/C/efhHPz7bPjz/WXqKUv4TI0TkW64H+Pfe6uW4L6omqrqJxU8/Vy8RFFcL99uuOoxgK+Brqq67gzCW4n7Yj0b74teRFoBzXz2+RpIAYpV9ZsfHMF/S3Bf7P8oZ5u/16TEOlwV6wBOXKNQ4Dxg4hnE6a9c4EYRifcp5eiHu54rVXWviGzFvYdzvfgE1/5rq88xjgCtVbW8kswKeed/E3hTRF7FtQ/rgKs+Lmv/ncC/gX+LyEfAJK9E6WsgVUTSyinly8Vdb18DcFW6pyrpOZ17NRcYJSIhPonrANx7vr4Sxynte0p1nPFTVX4OKrrXBwALVfXZkhUiUroUsazXscP7N9VnXc+KAlLVfBHZDLRX1X+dYr9juHt5rog8hCuZvQR4sYzd/YpFVQ/jSo0/FNfZaBuuPfF8Kv5s5AI/E5FYVS1JYM8tL35Tv1jCZ6pbpIg0xf3oN8ElOL8FFgNPAqjqGhH5D/CqiNyJ+yFphGv/9Y2qvu1zvAe8qsEtwIO4L/mSZOb/AQtE5G/A34H9uI4Bl6rqz/0JVlVXi8jHuKqccbgShqc4uVRtNq7a9F0RuQfXkaQpLomdrarz/Lw2jwPvi8g67zUIbuiav1fympTEfsCrfpogIjuBDbhG5CnA837GdCb+g+u88C8ReRBoiHsf3vZJbP4CjBeRNbjq4f/F/QBu9V7DfhF5EnjSSwY/xbXVPBeXWJT1Q3oSEfmNd7xsXMnHWFyJUF45+z+Ku74rcN+JV+Ku8RERmQMsBKaKyB24hLEDEKuq03AlMF95vUQn4v6jcCfuHj+V07lXn8e1IXteRP6C69wwAXhWVQ9WcL5T2YjrjZuJS74O+nm8Kvkc+HmvrwGuF5ERuP/YjMZ1CtpT6nWM8ErIdgF7VfWQiCwA7hWR9bge6n/wJy5cW8y/iutZPR1XdXoW0FxV/yAil+Cqrj/FNdEYAsTj/tNY1uusMBZxvebDcPdcIXAN7h5e6+dnYyLue+UV775uBtzv5+s1wS7QjQhtCd4F15ZKveUYsBPXqPxXQESpfcNxX7Df4JK4bbjG9L297YO94/wI167oCO6H4exSx+mDa/eyD1dFswx41Gd7Fu4HsnScH/g8TvHOfQjX2/NmYDlepw1vn3hc8pLnxbsJmIwrEYAyGsL7vIbGPut+hEt+j3jX5z0gyp9rUs41j8RVfeV7x1wADCi1j7+dNkpfp5OugbfueK9F73F3XIeJQ7gf41eBBJ/tYbhqzAJv+SuuDV2Wzz7i3SMlpX07cO2lMn32OVWnjVu8e2O/dx/8F+h3itd6Py7ZO4j74Z6OTycNXJvLf3hxHPbiGuWz/UrvPiu5D+7Hp8MILhG5q4zznvJeLSfWQbhk4Ij3Hv8ZiKzM/V3OcV/w7j/lROekH8Rd+vhU8Dko51wnddrw8/MfAbzs3VMF3t8PAht9jtEE145uPz6dFHDt2j733t9luCrosjpt9Ckj1jHevXTYO/dnwGhv2wDgE1xyeQj3+Si3N7ifsVyOK8kr8O6Jr4BLKvnZOMeL+QhugPVLfa+HLfV3EdXTadpjTM0SN17YJ0ATddVvxhhjjPGTDbxsjDHGGBPkLOEzxhhjjAlyVqVrjDHGGBPkaqyET9wchCvEzSs6SUSixM0vuVnc3KjZIjLSZ//xIrJORFZLBfOHGmOMMcaY8tVICZ+INMf1bkpX1zV9Cq4nXBtcT8YnS+2fDkzCjc/VDNf9v5OqFlV7sMYYY4wxQaYmx+ELA6JF5ChuOp4tuISvLJfh5hg9gptiZh0u+St3ipjGjRtrmzblHa7qHDhwgNjY2Go/jzHGGGMCoyZ+6xcvXrxTVZtU60l81EjCp6qbvQEjv8ONVzRTVWeKSD/glyLyU9w8hneq6h6gOW78sBJ53rpytWnThkWLSk9XWfWysrIYPHhwtZ/HGGOMMYFRE7/1IlKVc0FXqEYSPhFpiCu1a4sbUPJNEbkWN9jnY7hBIR/DjVp/I2XPB/iDumdvJoRxACkpKWRlZVVH+CcpLCyskfMYY4wxJjCC8be+pqp0hwEbVHUHgIi8jRv5/vWSHUTkH8AH3sM8oKXP81vgqoBPom4qmRcB+vTpozVR8mYlfMYYY0xwC8bf+prqpfsdcK6IxHhzAA4FVoqI7yTSV+CmpgE3pc5oEYkUkbZAR+DLGorVGGOMMSao1FQbvoUi8hZufr9juAm6XwReEpGeuOrajcDPvf1XeD15c739b7UeusYYY0zwOHr0KHl5eRw+fDjQofxAQkICK1eurJJjRUVF0aJFC8LDw6vkeKerxnrpqupDwEOlVl93iv0fBx6v1qCMMcYYExB5eXnEx8fTpk0bXOVf7bF//37i4+PP+Diqyq5du8jLy6Nt27ZVENnps6nVjDHGGFPjDh8+TFJSUq1L9qqSiJCUlFQrSjEt4TPGGGNMQARzsleitrxGS/j8tXQK/LkbbM12/y6dEuiIjDHGGHOaCgoKeP755yv9vJEjR1JQUFANEVUvS/j8sXQKvP9r2LvJPd67yT22pM8YY4ypk8pL+IqKTt1HdPr06SQmJlZXWNWmJqdWq7vmPApHDwHQfI83u9vRQ259j1EBDMwYY4ypH6Yt2cwTM1azpeAQzRKjuXt4Zy7vdcpJuE7pvvvuY/369fTs2ZPw8HDi4uJITU0lOzubhQsXcvnll7Np0yYOHz7Mbbfdxrhx44ATM3sVFhYyYsQIBgwYwBdffEHz5s159913iY6OrqqXXKWshM8fe/OO/9lx+8c+6zfBsSMBCMgYY4ypP6Yt2cz4t5exueAQCmwuOMT4t5cxbcnm0z7mhAkTaN++PdnZ2TzxxBN8+eWXPP744+Tm5gLwyiuvsHjxYhYtWsQzzzzDrl27fnCMtWvXcuutt7JixQoSExOZOnXqacdT3Szh80dCi+N/ftnm1pO3PdkJPvgNbPoK9AezvxljjDHmDD0xYzWHjp5c1XroaBFPzFhdZefo27fvSUOnPPPMM2RkZHDuueeyadMm1q5d+4PntG3blp49ewLQu3dvNm7cWGXxVDVL+Pwx9EEId0W0ByOT3bqwKOh/O3TMhOyJ8PIweLYPfPoEFGwKYLDGGGNMcNlScKhS609HbGzs8b/nzZvH7NmzmT9/Pjk5OfTq1avMoVUiIyOP/x0aGsqxY8eqLJ6qZm34/FHSTm/Oo+7fhJYuCSxZf3gf5L4LOZNh7u9h7uPQZgD0HAtpP4LIuMDEbYwxxgSBZonRbC4juWuWePrt5eLj49m/f3+Z2/bt20fDhg2JiYlh1apVLFiw4LTPU1tYwuevHqPckpUFY5afvC2qAZx1nVv2bHS9d7MnwrT/gQ/vdElfxmhoOwhCQgMRvTHGGFNn3T28M+PfXnZStW50eCh3D+982sdMSkqif//+dOvWjejoaFJSUo5vGzZsGK+99ho9evSgc+fOnHvuuWcUf20gGiTtzvr06aOLFi2q9vNkZWUxePDgindUhU0LIWcSLH8HjuyFBs1d0pgxFpp0qvZYjTHGmNpq5cqVpKWl+b1/VffSPZWqmlqtRFmvVUQWq2qfKjtJBayEr7qIQKtz3XLRBFj9kUv+Pn8GPvszNO8NGWOg248hplGgozXGGGNqtct7Na+2BK8+sISvJoRHQ7cr3bI/H5a96dr7Tb8LPh4PnYa79n4dMiEsItDRGmOMMSbIWMJX0+JToN8v3bJtmUv8lk6BVR9ATBJ0u8q192vWy5USGmOMMcacIUv4Aqlpd7cMewTWz4WcibD4Vfjy79Cki0v8elwDDZoFOlJjjDHG1GGW8NUGoWHQ6UK3HNoDK6a59n6zH3ZDwbQb7Nr7dbkEImICHKwxxhhj6hpL+Gqb6IbQ5wa37FrvqnxzJsPbt0BEHKRfDj3HQKt+EGLjZhtjjDGmYpYx1GZJ7eGC++G2HLj+Q+h6uRvg+dWL4ZkMN8DzrvWBjtIYY4ypcwoKCnj++edP67lPP/00Bw8erOKIqpclfHVBSIibueOy5+CuNXDlS5DUAeY9CX89C16+EBa9AocKAh2pMcYYUyfUt4TPqnTrmogY6HG1W/ZtcT18cybBB3fAR/dB5xFuiJf2Q13bQGOMMSYYLJ3i2rXvzYOEFidPcXoa7rvvPtavX0/Pnj3JzMwkOTmZKVOmcOTIEUaOHMmECRM4cOAAo0aNIi8vj6KiIn73u9+Rn5/Pli1bGDJkCI0bN+aTTz6pwhdZfSwjqMsaNIMBt0P/22BrNmRPcmP85U6D2CbQfZRr79e0e6AjNcYYY07f0inw/q/hqDef7t5N7jGcdtI3YcIEli9fTnZ2NjNnzuStt97iyy+/RFUZOXIkn376KTt27KBZs2Z8+OGH7rR795KQkMBTTz3FJ598QuPGjavi1dUIq9INBiJu3L6Rf4Q7V8PoiW6Gjy9fhL8NgBf6wxfPukGfjTHGmLpmzqMnkr0SRw+59VVg5syZzJw5k169enHWWWexZs0a1q5dS/fu3Zk9ezb33nsv8+bNIyEhoUrOFwg1lvCJyB0iskJElovIJBGJEpFGIjJLRNZ6/zb02X+8iKwTkdUiMrym4qzzwiKgy8Vwzeuuvd/IJyEsEmbeD0+lwX+uhuVT4ejhQEdqjDHG+GdvXuXWV5KqMn78eLKzs8nOziYnJ4ebbrqJTp06sXjxYrp378748eN59NGqSTADoUYSPhFpDvwa6KOq3YBQYDRwHzBHVTsCc7zHiEi6t70rcBHwvIiE1kSsQSWmEfS9BW6ZC7d+5ap+81fAWzfCk53gvV/DdwtANdCRGmOMMeVLaFG59X6Ij49n//79AAwfPpxXXnmFwsJCALZs2cL27dvZsmULMTExXHvttdx11118/fXXP3huXVGTbfjCgGgROQrEAFuA8cBgb/trQBZwL3AZMFlVjwAbRGQd0BeYX4PxBpcmnWDYQ3DBA7Bx3on2fl+/Bg3buoGdM66Bhm0CHakxxhhzsqEPntyGD9w89UMfPO1DJiUl0b9/f7p168aIESMYO3Ys5513HgDR0dFMmjSJdevWcffddxMSEkJ4eDgvvPACAOPGjWPEiBGkpqbWmU4bojVUuiMitwGPA4eAmar6ExEpUNVEn332qGpDEXkWWKCqr3vrXwY+UtW3Sh1zHDAOICUlpffkyZOr/XUUFhYSFxdX7eepCaHHDtF453yabvuExIJlCEpBQle2Nb2AHU36URRms3oYY4ypHgkJCXTo0MHv/cNWvkPkvAnI/i1ofDOODLyPY2lXVEtsRUVFhIZWXcXiunXr2Lt370nrhgwZslhV+1TZSSpQIyV8Xtu8y4C2QAHwpohce6qnlLHuB5mpqr4IvAjQp08fHTx48JkHW4GsrCxq4jw1Z4T7p2ATLH2DxJxJJK7+K13WvwRpl7j5fNsNgRCrUTfGGFN1Vq5cSXx8vP9P6PtTt+CShOjqCQuA/fv3Vy62CkRFRdGrV68qO97pqKkq3WHABlXdASAibwP9gHwRSVXVrSKSCmz39s8DWvo8vwWuCthUl8SWMOguGHgnbF4M2RNd545lb0JcU9ftvedYSE4LdKTGGGOMqaSa6qX7HXCuiMSIiABDgZXAe8DPvH1+Brzr/f0eMFpEIkWkLdAR+LKGYq3fRKBFH7jkKdfLd9S/oPlZsOB5eP5c+PsgWPA3OLAz0JEaY4wxxk81UsKnqgtF5C3ga+AYsARXFRsHTBGRm3BJ4dXe/itEZAqQ6+1/q6oW1USsxkdYJKRf5pbCHbD8LTerx8f3umFeOl7oOnt0Gu72NcYYYypBVXHlQMGrpvpKVKTGeumq6kPAQ6VWH8GV9pW1/+O4Th6mNohrAuf+j1vyc13it3QKrJ4O0Q2h249d8te8tyslNMYYY04hKiqKXbt2kZSUFLRJn6qya9cuoqKiAh2KTa1mTkNKOlz4GAx9CDZkuSFelrwOX70ESR1dR4+M0Wc0PpIxxpjg1qJFC/Ly8tixY0egQ/mBw4cPV1mSFhUVRYsWgf89tITPnL7QMOgwzC2H97k5fHMmw9zHYO7voe1AyBgLaZdCZHAMZWOMMaZqhIeH07Zt20CHUaasrKyA96qtajaXrqkaUQ3grJ/CDdPh19kweDwUfAfTfuFm9XjnF/BNFhQXBzpSY4wxpt6xEj5T9Rq1hcH3wvn3uKnbcibBinfcvw1anBjipXHHQEdqjDHG1AuW8JnqIwKtz3PLiP/nOnhkT4LPn4bPnnIdPDLGuA4fMY0CHa0xxhgTtCzhMzUjPNoldt1+DPvzYdkUl/xNvws+Hg+dL3Lt/TpmQmh4oKM1xhhjgoolfKbmxadAv1+5ZetS19Fj2RRY+T7EJEH3q10v39SeNsSLMcYYUwUs4TOBldrDLZmPwLo5rp3foldg4d+gSZpL/HpcAw1SAx2pMcYYU2dZwmdqh9BwV63b+SI4tMd18sieBLMfgjmPQLvBrsq3y8UQERPoaI0xxpg6xRI+U/tEN4Q+N7pl13pX6pfzBrx9M0TEQ9fLXPLX6jwIsZGFjDHGmIpYwmdqt6T2cMEDMPi38O3nrr3fimluZo/EVq6Xb49r3H7GGGOMKZMVj5i6ISTEzdxx+XNw1xq48h/QqD3894/w17Pg5eGw6J9wqCDQkRpjjDG1jpXwmbonItYN3txjFOzdfGKIlw9uh4/uhS4jXZVv+wvc9G/GGGNMPWe/hqZuS2gOA+6A/rfDliWuvd+yt1ynj9hklxRmjIam3QMdqTHGGBMwlvCZ4CACzc9yy4WPw9qZLvlb+HeY/yykdIeeY9wYf3HJgY7WGGOMqVGW8JngExYBaZe45cAuWPE2ZE+EGb+Fmb+DDsNcqV/nkRAeFehojTHGmGpnCZ8JbrFJ0PcWt+xYfWKIl7UzIDIBul3h2vu17GuzehhjjAlalvCZ+qNJZxj2MFzwO9jwqUv+lk6Bxa9Co3Ynhnhp2DrAgRpjjDFVyxI+U/+EhEL7IW45sh9y33PJ3yePu6X1AFflm34ZRDUIdLTGGGPMGbNx+Ez9FhkPvX4C138Aty9zgzzv3wrv/RKe7ARTb3Fz/BYXBTpSY4wx5rRZCZ8xJRJbwaC7YeBdkLcIcibC8qlunL/4VG+Il7GQ3CXQkRpjjDGVUiMlfCLSWUSyfZZ9InK7iDwsIpt91o/0ec54EVknIqtFZHhNxGkM4DpvtDwbLvkz3LkGrn4NUjPgi2fh+XPg7+e74V4O7Ax0pMYYY4xfaqSET1VXAz0BRCQU2Ay8A9wA/FlVn/TdX0TSgdFAV6AZMFtEOqmq1auZmhUeBV0vd0vhDlj2pmvv99E9bpiXjsNde79OwyEsMtDRGmOMMWUKRJXuUGC9qn4r5Q+DcRkwWVWPABtEZB3QF5hfQzEa80NxTeC8/3VL/ooTvXxXfwjRDaHbj12Vb/OzbIgXY4wxtUogOm2MBib5PP6liCwVkVdEpKG3rjmwyWefPG+dMbVDSle48PdwRy78ZKqbt3fJ6/DSBfBcX5j3J9ibF+gojTHGGABEVWvuZCIRwBagq6rmi0gKsBNQ4DEgVVVvFJHngPmq+rr3vJeB6ao6tdTxxgHjAFJSUnpPnjy52l9DYWEhcXFx1X4eU/eEHjtA8vbPScn/hMS9uShCQWJ3tjW9gJ2Nz6UoLDrQIRpjjPFDTfzWDxkyZLGq9qnWk/io6SrdEcDXqpoPUPIvgIj8A/jAe5gHtPR5XgtcongSVX0ReBGgT58+Onjw4OqJ2kdWVhY1cR5TV13s/tn9DZLzBg1zJtFw1dMQHuvG9csYDW0GQoiNiGSMMbVVMP7W1/Svzhh8qnNFJNVn2xXAcu/v94DRIhIpIm2BjsCXNRalMWeqUTsYMh5uy4EbPoLuP4ZVH8C/fgRPd4c5j8LOtYGO0hhjTD1RYyV8IhIDZAI/91n9RxHpiavS3WxRVjgAACAASURBVFiyTVVXiMgUIBc4BtxqPXRNnSQCrfu5ZcQfYdWHrrPHZ3927fya94GeY6DrlRDTKNDRGmOMCVI1lvCp6kEgqdS6606x/+PA49UdlzE1Jjwaul/llv3bXA/fnEnw4Z3w8XjodBH0HAsdhkFoeKCjNcYYE0Rspg1jAiG+KfT/NfT7FWxbCjmTXQK48j2IaQzdr3bt/VIzbIgXY4wxZ8wSPmMCScQldakZkPkorJvtSv0WvQwLX4DkdJf4dR8FDVIrPp4xxhhTBkv4jKktQsOh8wi3HNwNK95xyd+sB2H2w9BuiKvy7TwSImICHa0xxpg6xBI+Y2qjmEZw9k1u2bnOm9XjDZh6E0Q28IZ4GQOtzrMhXowxxlTIEj5jarvGHWDo72DI/fDtZ6693/K3Ycm/IbG1q/LNGO2GgjHGGGPKYEUDxtQVISHQdhBc/jzcvRau+Ds0agv//SM80wteuQgWvwqH9wY6UmOMMbWMlfAZUxdFxJ4o2dubd2KIl/dvg4/ude38eo517f5C7WNujDH1nf0SGFPXJbSAgb+BAXfAlq8hexIsfwtWvA1xKW6Il55jIaVroCM1xhgTIJbwGRMsRKB5b7cM/z9YO8O191v4N5j/LDTtDhlj3cDPccmBjtYYY0wNsoTPmGAUFgFpl7rlwC5YPhVyJsKM8TDzATebR88x0GkEhEcFOlpjjDHVzBI+Y4JdbBKcM84t21edGOLlzRkQleDm8e05FlqcbbN6GGNMkLKEz5j6JLkLZD4CQx+EDf91Vb45k2HxP6FReze2X8Y1kNgq0JEaY4ypQjYsizH1UUgotL8ArnzRDfFy2XPQoBl88nt4uju8egkseR2O7A90pMYYY6qAJXzG1HeR8dDrWrj+A7htKQx5APZthndvhSc6wtRbYP1cKC4KdKTGGGNOk19VuiIiwM3AGKCxqvYQkUFAU1WdUp0BGmNqUMPWcP7dMOguyPsKsie64V2WTYH4ZtBjlGvv16RzoCM1xhhTCf6W8D0K3AS8CJQ07skD7q2OoIwxASYCLfvCpU/DnWvg6lfdsC5f/BWe6wsvDoaFL7oewMYYY2o9fzttXA/0UtWdIvKCt24DYJN3GhPswqOg6xVuKdwOy950PX0/uhtm/BY6DXczfnQc7oaDMcYYU+v4m/CFAoXe3+r9G+ezzhhTH8Qlw3m3umXbcm+Ilymw6gOIbgjdrnLj+zU7y4Z4McaYWsTfKt2PgKdEJBKOt+l7DHi/ugIzxtRyTbvB8MfhNyvhJ2+5eXu//hf84wJ47hyY9xTs3RzoKI0xxuB/Cd8dwGvAXiAcV7I3E/hpNcVljKkrQsOgY6ZbDhVA7jQ3n++cR2DOo9DufDelW9olEBEb6GiNMaZeqjDhE5FQ4CpcD90GQGtgk6puq+bYjDF1TXQi9L7eLbu/gZw3XLXvO+PgwzhIv8y192s9AEJsVChjjKkpFSZ8qlokIk+p6ivAYWB79YdljKnzGrWDIePh/Hth0wJviJdpkP0fSGgJPa5xM3s07hDoSI0xJuj5+1/s90Xk0tM9iYh0FpFsn2WfiNwuIo1EZJaIrPX+bejznPEisk5EVovI8NM9tzEmwEJCoHU/uOxZuGsN/PhlaNwJPnsKnu0NLw2Dr16GQ3sCHakxxgQtf9vwRQFvich8YBMneuqiqhW241PV1UBPOF5FvBl4B7gPmKOqE0TkPu/xvSKSDowGugLNgNki0klVbah/Y+qyiBjofpVb9m11AzpnT4IPfwMf3wedR7hSvw7DIDQ80NEaY0zQ8DfhW+4tVWEosF5VvxWRy4DB3vrXgCzcYM6XAZNV9QiwQUTWAX2B+VUUgzEm0BqkQv/boN+vYWuOa+u37E3IfRdim0D3q117v6Y9bIgXY4w5Q6KqFe9VlScUeQX4WlWfFZECVU302bZHVRuKyLPAAlV93Vv/MvCRqr5V6ljjgHEAKSkpvSdPnlzt8RcWFhIXF1ft5zGmPpLiYzTavZim2z4haddXhOgxCmNbk58yhPyU8/k+slGgQzTG1AM18Vs/ZMiQxarap1pP4sPvhE9EhgDXAc1xVbKvq+rcSp1MJALYAnRV1fxTJHzPAfNLJXzTVXVqecfu06ePLlq0qDLhnJasrCwGDx5c7ecxpt47uNvN45s9CTYvAgmB9he4Kt8uF0N4dKAjNMYEqZr4rReRGk34/Oq0ISI3A28A24C3ga3ARBG5pZLnG4Er3cv3HueLSKp3jlRO9ADOA1r6PK8FLlE0xtQXMY3g7Jvhljnwy0Uw4A7Yvgqm3gRPdoL3fgXffgE1XEthjDF1kb9t+O4BMlU1p2SFiLwBTAX+UYnzjQEm+Tx+D/gZMMH7912f9RNF5Clcp42OwJeVOI8xJpg07ghDH4QhD8DGeZAzGZZNdTN7NGzjSv16XAON2gY6UmOMqZX8TfiSgNxS61YDfjeoEZEYIBP4uc/qCcAUEbkJ+A64GkBVV4jIFO+cx4BbrYeuMYaQEDdzR7vzYeQTsPJ919kjawJk/QFa9XMdPbpeDlEJgY7WGGNqDX8Tvs9wc+neq6oHRSQW+APwhb8nUtWDuMTRd90uXK/dsvZ/HHjc3+MbY+qZyDjoOcYtBZtODPHy/q/ho3tcO7+MsdBusJv+zRhj6jF/vwV/AUwG9orIblzJ3hfA2OoKzBhj/JbYEgbeCQN+A5u/hpyJsOwtWD4V4lKgxyhX7ZvSNdCRGmNMQPjVaUNVt6rq+UBb4FKgraqer6qbqzW6WmTaks30nzCXZZv30n/CXKYtqTcv3Zi6QwRa9IaL/+Rm9Rj1b2jeBxa8AC/0g78NhPnPQ+GOQEdqjDE1yq8SPhG5ENioqmtwPWgRkc5AK1WdVY3x1QrTlmxm/NvLOHS0CFrC5oJDjH97GQCX92oe4OiMMWUKi4T0H7nlwE5X2pc9EWaMh1m/gw6Zrr1f5xFuX2OMCWL+zqX7HLC/1Lr93vqg98SM1S7ZA97a4C7ZoaNFPDFjdSDDMsb4K7YxnPNz+Pl/4X8XwHm3wtZsePNnboiXD+6ATV/ZEC/GmKDlb8KXrKpbS63bCjSt4nhqpS0Fh47/ve/7E1M8bS44xDNz1rJy6z5qesYSY8xpSk6DzEfhjhVw7dvQMdN19nh5GDzbBz59Agq+C3SUxhhTpfzttPGNiFxQamaNwcCGqg+p9mmWGM1mL+m7oVMRTy13ly08VPjz7DU8NWsNLRpGk5meQmZ6Cn3bNCIs1N9c2hgTECGh0GGoWw7vc3P45kyGub93S5uBrqNH+o8gMj7Q0RpjzBnxN+F7GHjbm+JsPdAeuMFbgt7dwzsfb8NXMod7dHgof7iyO/06JDFn5XZm5ebzn4Xf8c/PN5IQHc6Qzk3ITG/K+Z2bEBdpQ0IYU6tFNYCzrnPLno2wdIpr7/fu/8L0uyDtUpf8tR3kEkVjjKljKjOXbl/gRtyUZ5uAl1X1q2qMrVKqey7daUs288SM1YxuuZ/Jm+K5e3jnH3TYOPj9MT5ds5NZufnMXZXPnoNHiQgN4bz2ScdL/1IaRFVbjMaYKqQKmxa6gZ2XvwNH9kKD5ieGeGnSOdARGmOqSTDOpet3wlfbVXfCV8Lfm+BYUTGLv93DrNx8Zq3M59tdBwHIaJHgJX9N6ZQSh4hUcCRjTMAdPQSrP3JVvutmgxZBs7Nc4tf9KjfvrzEmaNTbhE9EfgPMVdVsETkHeBM35dlPVHV+Ncfol9qW8PlSVdZuL3TJX24+2ZsKAGjVKIZhaa7k7+w2Da3dnzF1wf58WPamS/7yl0FIOHQa7pK/jhdCWESgIzTGnKH6nPBtArqp6l4R+QR4FzcsyzhVPaeaY/RLbU74Stu+7zCzV25nVu42Pl+/i++PFZMYE84FnZPJTE9hUKcmxFq7P2Nqv23LXOK3dAoc2A7RjVyJX8YYaNYLrATfmDopGBM+f7OKBC/ZiwcygGGqWiQif6rG2IJWcoMoxp7TirHntOLAkWN8umaHa/e3ejtvL9lMRFgI/dsnkZnelGFpySRbuz9jaqem3d0y7BFYP9dN6bb4NfjyRWjSxQ3s3H0UJNgA7caYwPI34dskIv2ArsCnXrLXACiqvtDqh9jIMEZ0T2VE91SOFRXz1caSdn/b+OSdZfz2HchomciFXqePjsnW7s+YWic0DDpd6JZDBbDiHVfyN/thmP0ItBvsSv3SLoGI2AAHa4ypj/yt0h0JvAR8D/xYVReLyFjgOlUdUc0x+qUuVen6Q1VZk1/IrNxtzMrNJydvLwCtk2LI9Nr99W5t7f6MqdV2rYelb7ievgXfQUQcpF/mkr/W/SHEPr/G1EbBWKV72r10RSQcQFWPVmlEpynYEr7Stu09zOyVrtPH/PW7+L6omIYx4VzQJcVr99eYmAhr92dMrVRcDN994RK/Fe/C9/shoRVkXOOSv6T2gY7QGOMjGBO+084QakuiV180TYji2nNbc+25rSk8coz/rt7hlf5tY+rXeUSEhTCgQ2My01MYmpZMcry1+zOm1ggJgTYD3DLiCVj1oWvvN+9Pbiq3Fn2h5xjoegVENwx0tMaYIGRFQnVQXGQYF/dI5eIeqRwtKuarDbuZ5ZX+zV21HRHo2TKRzPQULkxPoX0Ta/dnTK0REQM9rnbLvi2uh2/OJPjgDvjoPug8wpX6dRgKoeGBjtYYEyRs4OVKClSVrj9UlVXb9h8f72/ZZtfur23j2OMzfZzVqiGhIZb8GVOrqMLWbNfRY9mbcHAXxDaB7le75C+1R6AjNKZesSpdU6uJCGmpDUhLbcCvh3Zk695DzM7NZ2ZuPv/8fAMvfvoNSbERXNDFjfc3sGMToiNsXlBjAk7EjdvXrBdkPuZm88iZCF/+AxY8DyndTgzxEp8S6GiNMXXQKRM+EblLVZ/0eZypqrN8Hj+lqr+pzgDN6UtNiOa689pw3Xlt2Hf46PHx/j5esY03F+cRGRbCwI4l7f5SaBwXGeiQjTFhEdBlpFsO7oblU12V78wHYNaD0H6oa+/XeSSERwc6WmNMHXHKKl0R2aeqDXwe71bVRuVtDySr0vXf0aJivtyw+3jV7+aCQ4jAWa0aHq/6bd8kLtBhGmN87VjjEr+lb8C+zRCZAF0vd1W+rc61WT2MqULBWKVbUcK3X1XjfR7vUdWG5W0/5YlEEnFj+XUDFLgRGA7cAuzwdvutqk739h8P3IQb3PnXqjrjVMe3hO/0qCq5W/cdT/5WbNkHQLsmXru/tBR6Wbs/Y2qP4iLYOA+yJ8HK9+DoQWjYxiV+GaPd38aYM1IfE74qK+ETkdeAear6kohEADHA7UChb7Wxt286MAnoCzQDZgOdVLXcmT0s4asamwsOMcdnvL9jxUrjuJJ2f00Z2LExUeHW7s+YWuFIoUv6cibBhnmAQqt+rso3/XKIqhUVMMbUOcGY8FXUaUNEpC1QUrwTUuqxX8U+3jRsg4DrAVT1e+D7UwwVchkwWVWPABtEZB0u+Zvvz/nM6WueGM1Pz2vDT712f1mrXbu/j5ZtY8qiPKLCQxjYsYlr99clmSRr92dM4ETGQc+xbinYdGJWj/d+BdPvhi6XuOSv3RAIsf+oGVOfVZTwxQLrODmxW38a52mHq7b9p4hkAIuB27xtvxSRnwKLgDtVdQ/QHFjg8/w8b52pQQ2iwvlRRjN+lNGM748Vs3DDLmbl5jPbq/4NEejd2rX7G5aWQjtr92dM4CS2hEF3wcA7YfNiyJ7oOnwsfwvimkKPUa7aNyU90JEaYwKgRsbhE5E+uASuv6ouFJG/APuAZ4GduDZ9jwGpqnqjiDwHzFfV173nvwxMV9WppY47DhgHkJKS0nvy5MnV/loKCwuJi6vfiY2q8u2+YpZsL2LJ9iK+218MQGqs0Cs5jLOSQ2mXGEKINSI3JqCk+ChJu76i6bZPaLR7MSFaxP649mxrOoTtyYM4GpEQ6BCNqZVq4rd+yJAhtacN3ymfKNIV+Jmq3uPHvk2BBaraxns8ELhPVS/22acN8IGqdvM6bKCqf/C2zQAeVtVyq3StDV/g5O056Er9Vuaz8JvdXru/SIalufH++newdn/GBFzhDm+Il4mwNQdCwqBDpqvy7XQRhFnzDGNK1Mc2fCcRkcbAWOCnQC/gI3+ep6rbRGSTiHRW1dXAUCBXRFJVdau32xXAcu/v94CJIvIUrtNGR+DLysRqak6LhjFc378t1/dvy96DR8las52Zufl8sHQrk7/aRHR4KIM6NWZYmhvvr1FsRKBDNqb+iWsC5/7CLfm53hAvU2DNRxCVCN1+7NoCNu9tQ7wYE4QqTPhEJBy4FJfkjQA24ZKws1X160qc61fAf7weut8ANwDPiEhPXJXuRuDnAKq6QkSmALnAMeDWU/XQNbVHQkw4l/VszmU9m3PkWBELvtnNrNxtzM7dzowVrt1fn9aNjo/316ZxbKBDNqb+SUmHCx+DoQ/Bhiw3xEv2f2DRy5DU0Q3v0uMa1y7QGBMUKhqW5VlgNHAUeBOYqKoLRGQrkKGq22smzIpZlW7tpqos37yPWbnbmJmbz6pt+wHomBx3PPnLaJFIiI33Z0xgHN4HudPcfL7ffg4ItBngSv3SfuR6BBtTTwRjlW5FCV8RsBt4ADdMyl5vvSV85oxs2n3w+GDPX27cTVGxkhwfydC0FC5MT+G89knW7s+YQNm9wVX35kyEPRshPMYlfT3HQJuBNsSLCXrBmPBVVKXbHleVezfwtIhMByYCIdUdmAluLRvFcOOAttw4oC0FB7/nk9XbmZWbz3vZm5n05XfERIQyyBvv74IuyTS0dn/G1JxGbWHwvXD+PbBpoRviZcU7sHQyNGjuqnszxkCTToGO1BjjJ7976Xo9a38KXA00AF4G/qyqudUXnv+shC84HDlWxPz13nh/K/PJ33eE0BChjzfe34XpTWmVFBPoMI2pf44egtXTXXu/9XNAi10Hj4wxrsNHTKOKj2FMHRGMJXyVHpZFRKKAK4GfAUNUtVYUvVjCF3yKi5Vlm/cer/pdne/a/XVOiT/e7q978wRr92dMTdufD8umuORv+woICYfOF7nkr0MmhNWKnwVjTpslfKWfLNJMVbdUYTynzRK+4PfdroPMzN3GrNx8vtq4m2KFlAau3V9megr92icRGWZti4ypUVuXuo4ey6bAgR0QkwTdrnLt/VJ72hAvpk4KxoTvlG34RORBP47xaBXFYswptUqK4eaB7bh5YDv2HDjR7m/aks1MXPgdsRGhnN/Ztfsb0jmZxBgrZTCm2qX2cEvmI7B+rmvvt/if8OXfoUkXV+rXYxQ0aBboSI2p1yrqtPEwsBr4ipPn0y1R/fOyGVOGhrERXHlWC648qwWHj7p2fzO9dn/Tl20jNETo2+bEeH8tG1m7P2OqVWg4dBrulkN7XCePnMkw+yGY8wi0G+ySvy6XQIR9Ho2paRUNy3I7cB0QDbwGvK6qm2sotkqxKl0Drt1fTl7B8U4fa/ILAejS9OR2f2LVTMbUjF3r3aweOW/A3u8gIh66XuaSv1b9IMQGfTC1TzBW6frVhk9E0nGdNEYDa3DJ35uqeqR6w/OfJXymLBt3HmD2ynxm5uazyGv317RBFMPSk8lMb8p57ZKICLMfHGOqXXGxG9A5Z7Ib4Pn7QkhsBT1Gu5k9ktoHOkJjjqu3Cd/xnUXCgP8DfgNcqKpzqyuwyrKEz1Rk94HvmbtqO7Nyt/Hpmp0cOlpEXGQY53duwoXpKQzunExCdHigwzQm+H1/AFZ96Nr7fZMFKLQ8x5X6db0CohMDHaGp54Ix4atwLl0AEUnjRAnfeuAm4ItqjMuYKtcoNoKrerfgqt6u3d/n63Z6Vb/b+XDpVsJChL5tT7T7a9HQ2hkZUy0iYl1Hjh6jYO/mE0O8fHA7fHQvdBnpkr/2QyHUr58pY0wFKuql+0tcohcD/BsYqKqbaiIwY6pTVHgoQ9NSGJqWQnGxku21+5uVm88j7+fyyPu5pKU28AZ7TqFrswbW7s+Y6pDQHAbcAf1vhy1LvCFe3nSdPmKTofvVboiXpt0DHakxdVpFnTaKcb10F1FOj1xV/Wn1hFY5VqVrqsqGnQeY5Y33t/jbPRQrNEuIYphX8ndOW2v3Z0y1OvY9rJ3pOnusmQHFRyGlmyv16341xKcEOkIT5Opjle6j2NArpp5p2ziWcYPaM25Qe3YVHmHOKjfe35RFm/jX/G+J99r9ZVq7P2OqR1gEpF3ilgO7YMXbrr3fzPth1oPQYahL/jqPhPCoQEdrTJ1wyoRPVR+uoTiMqZWS4iIZ1aclo/q05PDRIj5b69r9zVmVzwdeu79z2yWRmZ7CsPQUmidGBzpkY4JLbBL0vcUtO1afGOJl7Q0QmQDdrnDJX8tzbFYPY07hjKZWq02sStfUpKJiJXvTHmZ67f6+2XEAgK7NGhzv9JGeau3+jKkWxUWw4VPX3m/le3D0IDRs6xK/jNHQsHWgIzR1XDBW6VrCV0mW8JmyrN9R6Hr85uaz+Ls9qELzxGiGpbnx/s5p14jwUGv3Z0yVO7IfVr7vqnw3znPrWvd3yV/6ZRDVILDxmTrJEr5azBI+U1vsLDzC3JXbmZmbz7y1OzhyrJj4qDCGdE722v01IT7K2v0ZU+UKvoOlb7ghXnavh7Bo1w4wYzS0GwIhoYGO0NQRwZjw2QBHxlSxxnGRjDq7JaPObsmh74uYt3aH1+5vO+/lbCE81LX7u9Br95eaYO3+jKkSia1g0N0w8C7IWwQ5E2H5VDfMS3yqG/cvYwwkpwU6UmNqnL9Tq40BslV1pYh0Bv4BHAP+V1VXVXOMfrESPlPbFRUrX3+35/h4fxt2unZ/3Zo3IDOtKZnpKaSlxlu7P2Oq0tHDsOZj195v7UzQIkjt6Q3xchXENg50hKYWCsYSPn8TvvVAP1XNF5H3cWPzFQKDVPWCao7RL5bwmbpEVb12f26qtyWbClCFFg2jGZbmBns+u621+zOmShXugOVvufZ+25ZCSBh0vNAlf52GQ1hkoCM0tUQwJnz+Vuk28ZK9KGAAcBVwFNhZbZEZE8REhA7J8XRIjud/Brdn+/7DzF3pxvub9OV3vPrFRhpEhXFBF9fp4/zOTYiLtBYYxpyRuCZw7v+4JX+FG+Jl6RRYPR2iG0K3H7vkr3lvG+LFBB1/f0F2iEgHoDvwlaoeEZEYwO9PhIgkAi8B3XCDOd+IKyl8A2gDbARGqeoeb//xuDl7i4Bfq+oMf89lTF2THB/F6L6tGN23FQe/P8ana9x4f3NX5TMtewsRoSGc194b7y8thaYJNtisMWckpStc+HsY+jB8k+Xa+y15Hb56CZI6uo4eGaMhoUWgIzWmSvib8D0GLMYlX9d464YCOZU411+Aj1X1KhGJwM3P+1tgjqpOEJH7gPuAe0UkHRgNdAWaAbNFpJOqFlXifMbUSTERYVzUrSkXdWvKsaJiFn+7h9krXbu/B6Yt54Fpy+nRIoHMtBQyu6bQOcXa/Rlz2kLDoOMwtxzeCyumufZ+cx+Dub+HtoNcqV/apRAZF+hojTltfg/L4pXooaoHvcfJQIiqbvPjuQ1wyWE79TmhiKwGBqvqVhFJBbJUtbNXuoeq/sHbbwbwsKrOL+8c1obPBDtVZd32wuODPWdvKgCgZaPo450+zm7TkDBr92fMmdv9javuzZkEezZCeCyk/8glf20GQoh9zoJZMLbhq5Fx+ESkJ/AikAtk4EoLbwM2q2qiz357VLWhiDwLLFDV1731LwMfqepbpY47DhgHkJKS0nvy5MnV/loKCwuJi7P/5ZnAKzhcTPaOIr7eXkTuriKOFUNsOGQ0CaNXcijdGocSHWYlf8acEVUS9q4kJX8uyds/J6zoIIcjG5OfMphtTYdwKMaqfINRTfzWDxkypPYkfCJS7P2pqnraI1aKSB9gAdBfVReKyF+AfcCvykn4ngPml0r4pqvq1PLOYSV8pj47cOQY89buYGZuPnNXbafg4FEiQkPo18G1+8tMSyG5gbX7M+aMHD0Eqz50pX7r54IWQ/M+rq1ftx9DTKNAR2iqSDCW8J2yDZ+qVlWZdR6Qp6oLvcdv4drr5YtIqk+V7naf/Vv6PL8FsKWKYjEm6MRGhnFRt1Qu6pbKsaJiFn17Yry/+99Zzv3vLCejZSIXevP8dkyOs3Z/xlRWeLQbu6/7VbB/24kq3+l3wYzfuqFdMsZCx0wItdl0TO1SY1Oricg84GZVXS0iDwOx3qZdPp02GqnqPSLSFZgI9MV12pgDdDxVpw0r4TPmh1SVNfmFzMrdxqzcfHLy9gLQOimGzDQ300ef1tbuz5jTpurG9MuZ7BLAgzshJgm6X+3a+6Vm2BAvdVC9KuHzErQKs0FVHeTnuX4F/MfrofsNcAMQAkwRkZuA74CrvWOuEJEpuDZ/x4BbrYeuMZUnInRuGk/npvH88oKO5O87fLzH77/mf8tLn22gYUw4Q7okc2F6CoM6NSEmwsb7M8ZvIi6pS82AzEdh3Rw3xMuiV2Dh36BJGvQcA91HQYPUQEdr6rFyS/hE5Gf+HEBVX6vSiE6TlfAZUzmFR47x6Zod3nh/29l76CgRYSEM6NCYzPQUhqYlkxxv7f6MOS2H9sDyt12Vb95XICHQbogr9etyMUTEBDpCcwr1qoSvtiRyxpjqERcZxsjuqYzsnsrRomK+2rj7eLu/uau2IwI9WyYe7/TRwdr9GeO/6IZw9k1u2bnOm9XjDXj7ZoiIh66XufZ+rc6zIV5MjfB3Ll0BbgbGAI1VtYeIDAKaquqUao7RL1bCZ0zVUFVWbdvP7Nx8Zq3MZ6nX7q9NUoxL/tKb0rt1Q0JDLPkzplKKi+Hbz1x7vxXT4OgBSGx9YlaPRu0CHaHxBGMJn78J32NAJvA08DdVTRSRdsCbqtq7mmP0iyV8xlSPrXsPMdub53f++p0cLVIaxUZ48/ymMLBjY2v3Z0xlfX8AVn7g2vt9t2XeTwAAIABJREFU819AoeW5rr1f+uUQnVjhIUz1qc8J3yagl6ru9BkrT/j/7d13fNb1uf/x15VNSAiQxQp7JSJDcaAoG/eqVatVu6zt79jTHrvt0Wodp0Nrx/EsbY9ttWqtu2pFQHFPBATClL0S9l5Jrt8fn2/CfWiAgEnu5L7fz8cjj+T+3t/xSRBzcX2uz/WBTe7eoclH2QAK+ESa3vY9+3ktqvt7dX4l2/ZUkZmWwhn9ChhfWsy40mIKczPjPUyR1mXr6jDdO+tR2LAQUjNDnd+QK6HP2LD9mzSrRAz4GvpfUSqwI/q6NkLMiTkmIkkgNyud8wd34fzBXdhfXcP7Sw/U/U2ZV4nZbIaVtGdCWdjqrW+RdqUROaK8rnDGt2HkjbDmI5j5KMx5AuY+BW2LYPDlIfjrNCjeI5VWrKEZvt8B+4AbgbVAPvArIMPd/6lJR9hAyvCJxI+7M2/t9hD8zVvHnNXbAOhd0Daq+ytmWHfV/Yk0WNU+WDQp1PstfAlqqqD4+KjFy2WQUxTvESa0RMzwNTTgawf8CTgbSAf2AC8D17r79iYdYQMp4BNpOdZs2V3X7+/dJRvZX+3kt81gXGkRE8o6MbJvAW0yjnm3RpHksnMjzHky1PutmQGWCn3Hh4UeA86FdLVPamyJGPA1aErX3bcBF5tZMdAdWOnu65p0ZCLSanVp34ZrR/Tk2hE92bZnP9MWhLq/v89ex+MfriIrPYWRfQuZWFbM2NIiCnJU9ydySG3z4ZTrw0fl/KjFy+MhA5iZB4MuCS1eSk7Wrh5ySIfbaaO+xkDro4+69929pmmGJiKJoF1WOhcO6cKFQ7qwr6q27m9dVPdXgRmc2L1D3dRv70LV/YkcUtFAmPATGPdjWPpamPKd9ReY/ofQ1mXIlTD4CujQI94jlRbmcDtt1NCwrdVaxLyMpnRFWhd3Z+6abXWLPsrXhrq/PoVt6xZ9DCtpT4rq/kQOb+92KH82BH/L3gjHeoyMWrxcBJm58R1fK5RsU7q9Yr4+D/gs8FNgOdAD+AHwZNMNTUQSmZkxqGseg7rmceOE/qzavKuu2fPv3ljCf7/2CQU5GYwbGDJ/I/sVkJXeIv59KdKyZObCsKvDx+blYbp31iPw7A3wwneh9IJQ79d7NKTo71CyauiijcXAcHffEnOsA/Chu/dpwvE1mDJ8Iolj6+79TFsQmj2/tmA92/dW0SY9lTP61e7zW0zHthnxHqZIy+Ue9vCd+Uho77JnK+R2jlq8XBWmhuWQki3DFysPyAa2xBzLjo6LiDSqvDbpXDS0KxcN7cq+qhreXbKxrubv5fIKUgyG9+hYV/fXs6BtvIcs0rKYhUUcJSfD2T+DhX8PU75v3wdv/QY6D4WhV8Ggz4ZFIZLwGprhuwc4l7C12kqgBPgmMMndv9OkI2wgZfhEEp+7M2f1trDoY14l86K6v35FOYyPgr+h3VT3J3JIOyph9hNhynfdbEhJg35nhXq/fmdBmjLnkJgZvoYGfCnA9cBlQBdC8+XHgQfcvbpJR9hACvhEks/KTbvq+v29t3QT1TVOYW4m40vDPr+n9VHdn8ghrZtzoMXLzkpo0yFk/IZcCV1PSOoWL0kb8LUGCvhEktvWXft5Nar7m7agkp37qsnOSOXMfoVMKCtm7MAiOqjuT+QfVVfBkldDvd/8F6B6LxT0Dws9Bl8Bed3iPcJml4gBX4N3ZDazLwHXAF2B1cBD7v5gUw1MRORo5GWnc/Gwrlw8rCt7q6p555MDdX8vzV0X6v56dmRiNPXbI191fyIApKZBvwnhY/cWKH8m1PtNvR2m3gG9zgz1fqUXQIb+3rRWDZ3S/VfgWuCXHGjLciPwsLvf1aQjbCBl+ESkPu7O7NVb6/r9zV8XdoPsX5wTLfroxOCuear7EznYpiWhqfOsR2HLckhvG/r6Db0y9PlLqW9/hsSQiBm+hgZ8S4HR7r485lgP4HV3bxHtvBXwiUhDrNi4i8nzKphcvo4Plm2musYpys2sW/RxWp98MtNU9ydSp6YGVr4btXh5BvZth7ySMN075Eoo6BvvETa6RAz4Gjql25ZoS7UYG4E2jTscEZGm1T0/m6+M7MVXRvZiy659vDI/1P09M2M1j7y3grYZqZzZ/0DdX/ts1f1JkktJgR6nhY9zfgELXgzB35v3whv3QLeTQr3fcZ+B7I7xHq0cQkMDvpeAP5vZD4EVhCndu4BJTTUwEZGm1j47g8+c0I3PnNCNPfureae23195BX+fs47UFOOknh2YUNaJiWXFlHTMjveQReIrIxuO/2z42LYWZj8OMx+FF74DL90E/c8O9X59x0NqerxHKzEaOqXbDrgPuBxIB/YT2rJ8M3b3jSPcYxmwHagGqtx9uJndBnyVA9nDH7n7i9H5NwFfic7/prsfNrjUlK6INJaaGufj1VtDv7/yChZW7ABgYKfcumbPx3fNw5K4bYVIHXdYOyss9Jj9V9i1AbIL4PjLQuav85BW1+IlEad0j6otS9SPrwDY4O41R/WgEPANd/cNMcduA3a4+z0HnVsGPAqcTOj7NwXof7iefwr4RKSpLN+4s27RxwfLNlHjUNwuk/GlIfgbobo/kaB6PyyeEqZ8F74E1fugqCzU+g2+HHI7xXuEDZKIAd9hp3TNrPsh3upW+y9bd1/R2IMCLgIec/e9wNJoL9+TgXea4FkiIofVI78t153Rm+vO6M3mnQfq/p6esZo/v7eCnMw0RkV1f2MGFJGXraksSVKp6TDgnPCxa1PYx3fmozD5FphyK/QZG4K/gedBupYBNKcj1fAtA2pTgPXlYx1o6D9rHXjZzBz4H3e/Pzr+DTO7FvgQ+I67byb0+ns35tpV0TERkbjq0DaDS0/sxqUnhrq/tz/ZEGX/Knlh9lrSUoyTe4V9fseXqu5Pklh2RzjpuvCxYVFo7zLrL/DkVyCzXdTi5SroPqLVTfm2Roed0jWzmUAW8EfgYWDNwec0dGs1M+vi7mvMrAiYDPwzsADYQAgG7wA6u/uXzew/gHfc/eHo2t8DL7r7kwfd83rClm8UFxef+NhjjzVkKJ/Kjh07yMnJafLniEjrUuPOkq01zKioZkZlFWt2hv+3luSmMKwolROKUunRLkV1f5LcvIb2W+bQad2rFK5/m9SaPezOKqaieAzrOo1mT5vO8R4h0Dy/68eMGdOyavjMbBDwBcKCjfnAn4Cn3H33MT+0nto9M+sJPO/ug6IFG7j7T6P3JgG3ufshp3RVwyciLcnSDTuZEtX9fbg81P11zsuqq/s7tXc+GWmJ27hW5Ij27oD5z4d6v6WvAx6yfUM+B8ddAll5cRtaItbwNXjRRrRgYwLwReAcYKy7f9TAa9sCKe6+Pfp6MnA7MMvd10bn3Aic4u6fM7PjgEc4sGhjKtBPizZEpDXauGNvXd3fG4s2sHt/NbmZaYwaEOr+Rg8oIq+N6v4kiW1dBR//JdT7bVwEaVmhzm/IldB7TNj+rRklYsB3ND/BfsAoYAQwA9h8FNcWA09HUxlpwCPu/pKZPWRmQwlTusuArwG4+1wzexwoB6qAGxo6dSwi0tLk52Ry2fASLhtewp791by5KNT9TZ1fwfMfh7q/U3vnh7q/smK6tlcxuySZvG5wxndg5Ldh9Ucw6xGY/QTMeRJyikOLl6FXQfFx8R5pq3WkGr6OwJWEKd1c4CHC/rlNsTL3U1GGT0Ram+oaZ+bKzUwur2Ry+To+Wb8TgLLO7er6/R3XpZ3q/iQ5Ve2FhZNCf79Fk6CmCjodD0OuCo2fc4qa7NGJmOE7UsC3B1hKCPTere8cd3+laYZ2dBTwiUhrt2T9jrp+f9NXbMYdurZvw/jSIiaUdeKU3h1JT1XdnyShnRtCtm/mI7B2Jlgq9JsQ6v36nwPpWY36uGQM+JZxoC1Lfdzdezf2oI6FAj4RSSQbduzllXmVvFxewZuL17Nnfw25WWmMGVDEhLJiRg0opF2W6v4kCVXOCy1ePn4ctq8NizuO+0yY8u12UqO0eEnEgO+wNXzu3rOZxiEiIjEKcjK5/KQSLj+phN37qnlz8QYml69j6rxKnpu1hvTUmLq/0mK6qO5PkkVRKUy4HcbdCkumRf39HoPpD0LHPmGhx5AroP2h9o5ITke1tVpLpgyfiCSD6hpnxorNdVO/SzaEur9BXdsxobQTE8qKKe2cq7o/SS57tkH5syHwW/5mONbzjBD8lV0ImblHdbtEzPAp4DtKCvhEpCVZXFlb97eOGSu31NX91S76OLmX6v4kyWxeFqZ7Zz0Km5ZAejaUXhDq/XqNgpQjbxCWiAFf8za2ERGRRtW3KIe+RTn8v9F9WL99L6/MD5m/R99fwR/eXka7rDTGDIzq/voXkqu6P0l0HXrCqO/Dmd+Dle+HFi9zng59/nK7wODLQ71f4YB4j7RZKcN3lJThE5HWYNe+Kt6I+v29Mr+STTv3kZGawql9Qt3fhNJiOuU17spGkRZr/x5Y8GKY8l08BbwaupwQpnwHXQpt88N5Hz8OU29nWqfrGL3udzDuxyFAbAKa0j1GCvhEROpXXeNMX76ZyeXrmFxewbKNuwAY3C2PCaWh2fPATqr7kySxvQJm/zUEfxWzISUd+p8FeSVh4UfVHqYN+AmjF9wK6W3ggt82SdCngO8YKeATETkydw91f/PC1O+MFVsAKOnYpm6f35N7diRNdX+SDNbNDoHfx4/Dzsq6w9N7XM+Jy+8PL/JK4MY5jf5oBXzHSAGfiMjRq9y+h6nzwj6/by7ewL6qGvLapDM2qvs7s38hOZkq95YEV10Fd+TXvdyU3YeOuz6JXhnctqXRH6lFGyIi0myKcrO48uTuXHlyd3bureKNRet5Oar7e3rGajJSUzitb35d9q+4ner+JAGlpoVM3taVACwqPo9Tlv42vJfXLY4DazwK+EREBIC2mWmcPagzZw/qTFV1DR8uP9Dv7+YFc7j5mTkM6ZYXtXzpRP/iHNX9SeIY92P42zdh/252Z0TZvvQ24XgCUMAnIiL/IC01hVN753Nq73xuPq+URVG/v5fLK7jn5YXc8/JCunfMruv3N7xHB9X9SetWuzBj6u3hc15Jk67SbW4K+ERE5LDMjP7FufQvzuWGMX2p2LaHKdGij4feWc7v31xK++xQ9zexrJgz+hXSVnV/0hoNvjx8TJsGVzb+Qo140t9IERE5KsXtsvj8KT34/Ck92LG3itcXrmdyeQVT51Xy1EeryUhL4fQ++Uwo68T40iKKVPcnEncK+ERE5JjlZKZx7vGdOff4UPf3wbKo7m/eOl59ejY/ehqGlrRnQlkxE8uK6Vukuj+ReFDAJyIijSItNYURffIZ0SefW84vZUHFdibPrWDyvArunrSAuyctoGd+dt2ijxN7dCA1RcGfSHNQwCciIo3OzBjYqR0DO7Xjn8f1Y93WPXXNnv/w9jIeeGMpHbLTGTuwOOr3V0B2hn4liTQV/e0SEZEm1ykvi2tO7cE1p/Zg+579vL5wQ7TV2zqe/GgVmWkpjOxbwISyYsaVFlOYmxnvIYskFAV8IiLSrHKz0jlvcGfOG9yZ/dU1fLB0Ey9H/f6mzq/EbDbDStozoawTE6K6PxH5dBTwiYhI3KSnpnBa3wJO61vArReUMW/tdiaXVzBlXgU/f2k+P39pPr0L2jI+6vd3QnfV/YkcCwV8IiLSIpgZZV3aUdalHd8a34+1W3czJWr2/OBbS7n/9SXkt82o2+f3jH6FtMlIjfewRVqFZgv4zGwZsB2oBqrcfbiZdQT+AvQElgGXu/vm6PybgK9E53/T3Sc111hFRCT+Oue14ZoRPblmRE+27dnPawtCv7+X5q7jr9NXkZWewsi+hUwsK2ZsaREFOar7EzmU5s7wjXH3DTGvfwhMdfefmdkPo9c/MLMy4HPAcUAXYIqZ9Xf36mYer4iItADtstK5YEgXLhjShX1VNby/dBOTy9cxZV4lU+ZVYAYndO9Qt9Vbn0LV/YnEiveU7kXA6OjrPwLTgB9Exx9z973AUjNbDJwMvBOHMYqISAuSkZbCyH4FjOxXwG0XOuVrt4Vmz+UV/Ozv8/nZ3+fTu7BtXbPnoSWq+xMxd2+eB5ktBTYDDvyPu99vZlvcvX3MOZvdvYOZ3Qe86+4PR8d/D/zd3Z846J7XA9cDFBcXn/jYY481+fexY8cOcnL0L0cRkZZo4+4aZlRWM6Oyivmbaqh2aJcBQ4vSGFaUynH5qWSkKviTw2uO3/VjxoyZ7u7Dm/QhMZozw3e6u68xsyJgspnNP8y59f1t/IfI1N3vB+4HGD58uI8ePbpRBno406ZNozmeIyIix+bS6PPW3fuZtqCSyeUVvLZgPa+v2ktWegpn9CsM/f4GFpGvuj+pRyL+rm+2gM/d10SfK83sacIUbYWZdXb3tWbWGaiMTl8FlMRc3g1Y01xjFRGR1i+vTToXDe3KRUO7sq+qhveWbqyb+p1cXkGKwYk9OtRt9daroG28hyzSZJol4DOztkCKu2+Pvp4I3A48B3wB+Fn0+dnokueAR8zsXsKijX7A+80xVhERSTwZaSGzd0a/Qn5y4XHMXbOtrtnzv704n397cT59i3LqFn0M7daeFNX9SQJprgxfMfC0mdU+8xF3f8nMPgAeN7OvACuAywDcfa6ZPQ6UA1XADVqhKyIijcHMGNQ1j0Fd8/j2hP6s3LSLKfNCs+cHXl/Cf037hIKcTMaXhn5/p/ctICtd/f6kdWuWgM/dlwBD6jm+ERh3iGvuAu5q4qGJiEiSK+mYzZdO78WXTu/F1l37mbawkpfLK3j+47U89sFK2qSncmb/AiaUdWLswCI6ts2I95BFjlq827KIiIi0GHnZB+r+9lZV8+6SqN9feSWT5oa6v+E9OzIxmvrtka+6P2kdFPCJiIjUIzMtlVH9CxnVv5A7LnJmr95at+DjzhfmcecL8+gXU/c3RHV/0oIp4BMRETkCM2Nwt/YM7tae70wcwMpNu+qCv/95fQn/Oe0TinIzGVcamj2P6JOvuj9pURTwiYiIHKWSjtl8eWQvvjyyF1t27ePVqN/fczNX8+j7K8jOCNnBCWXFjB1YRPts1f1JfCngExER+RTaZ2dwybBuXDKsG3urqnn7k9Dvb0p5BX+fs47UFOOknh2YUNaJCaXFdM/PjveQJQkp4BMREWkkmWmpjBlQxJgBRdx50SA+Xr2VKdHU7x3Pl3PH8+UMKM6tq/s7vmue6v6kWSjgExERaQIpKcbQkvYMLWnPd88awPKNO+vq/v5z2mLue3Uxxe0yGV8agr8RffLJTFPdnzQNBXwiIiLNoEd+W647ozfXndGbzTv38cr8UPf39IzV/Pm9FeRkpjGqfyHjy4oYO6CYvOz0eA9ZEogCPhERkWbWoW0Gl57YjUtP7Mae/dW888lGXi4Pu328MHstqSnGyT071k39lnRU3Z98Ogr4RERE4igrPZUxA4sYM7CIu2oGMWvVlrqp39ufL+f258sZ2Ck3avbciUFd2xFtVSrSYAr4REREWoiUFGNY9w4M696B7589kGUbDtT93ffqYn77ymI652UxvrSY8WXFjOidT0ZaSryHLa2AAj4REZEWqmdBW756Zm++emZvNtXV/a3jiemreOjd5aHub0AhE8uKGT2giLw2qvuT+ingExERaQU6ts3gsyd247NR3d9bizeEfn/zKnnh47WkpRin9O7IhCj7162D6v7kAAV8IiIirUxWeirjSosZV1pMTY0zY2Vt3d86bvtbObf9rZyyzu3qFn0c10V1f8lOAZ+IiEgrlpJinNijAyf26MAPzxnIkvU76ur+fvvKIn4zdRFd8rIYHwV/p/RS3V8yUsAnIiKSQHoX5vC1UTl8bVQfNu7Yy9So39/jH67kT+8sJzcrjdEDiphQVszoAYW0y1LdXzJQwCciIpKg8nMyuXx4CZcPL2H3vmreXLyByeXrmDqvkr/NWkN6qnFq7/y63T66tG8T7yFLE1HAJyIikgTaZKTW1fRV1zgzVmyum/q99bm53PrcXI7rcqDur6yz6v4SiQI+ERGRJJOaYgzv2ZHhPTty07mlfBJT9/ebqYv49ZRFdG3fpi74O7lXR9JTVffXmingExERSXJ9CnPoMyqHr4/qw/rte3llfgj+Hn1/BX94exntstIYMzDU/Y3qX0iu6v5aHQV8IiIiUqcwN5MrTurOFSd1Z9e+Kt5YFPr9vTK/kmdnHqj7m1gW+v11zlPdX2vQrAGfmaUCHwKr3f18M7sN+CqwPjrlR+7+YnTuTcBXgGrgm+4+qTnHKiIikuyyM9I467hOnHVcJ6prnI9i6v5ueXYutzw7l+O75tVN/Q7slKu6vxaquTN83wLmAe1ijv3K3e+JPcnMyoDPAccBXYApZtbf3aubbaQiIiJSJzXFOKlnR07q2ZGbzhnIJ+t38HIU/P1qykLunbyQbh1i6v56diRNdX8tRrMFfGbWDTgPuAv49hFOvwh4zN33AkvNbDFwMvBO045SREREjsTM6FuUS9+iXP5pdF8qt+9h6rzQ7+/P763gwbeWkdcmnTEDCplQ1olRAwrJyVQVWTw150//18D3gdyDjn/DzK4lTPV+x903A12Bd2POWRUdExERkRamKDeLK0/uzpUnh7q/1xfW1v1V8MzMNWSkpjCiT35d9q+4XVa8h5x0miXgM7PzgUp3n25mo2Pe+i/gDsCjz78EvgzUVwDg9dz3euB6gOLiYqZNm9a4A6/Hjh07muU5IiIirVUWcEERnFuQzuItqXxUWcWMVRt4beF6bn5mDr3yUhhWlMoJRWl0zbEWV/eXiL/rmyvDdzpwoZmdS/jvoJ2ZPezuV9eeYGYPAM9HL1cBJTHXdwPWHHxTd78fuB9g+PDhPnr06KYZfYxp06bRHM8RERFJBOOiz+7OosoD/f6eWrSFpxbtp3vHbMaXhpYvJ/Xs0CLq/hLxd32zBHzufhNwE0CU4fuuu19tZp3dfW102iXAnOjr54BHzOxewqKNfsD7zTFWERERaXxmRv/iXPoX53LDmL5UbtvDlHmVTC5fx8PvLed/31pK++x0xkb7/J7Zv5C2qvtrNPH+Sf7CzIYSpmuXAV8DcPe5ZvY4UA5UATdoha6IiEjiKGqXxVWndOeqU7qzc28Vry9cH+r+FlTy1IzVZKSlcHqffCaUdWJ8aRFFqvv7VJo94HP3acC06OtrDnPeXYQVvSIiIpLA2mamcc7xnTnn+M5UVdfwwbKo39+8dbz69Gx+9DQMKWnPxGjRR7+inBZX99fSxTvDJyIiIlInLVrRO6JPPrecX8rCih1MLl/H5PIK7p60gLsnLaBHfjYTSkPwd2KPllH319Ip4BMREZEWycwY0CmXAZ1y+cbYfqzbuocp88Kijz+9s5zfvbmUDtnpjB1YHNX9FZCdodCmPvqpiIiISKvQKS+Lq0/twdWn9mDH3ipeW7A+yv6t48mPVpGRlsLIvgVMKCtmXGkRRbmq+6ulgE9ERERanZzMNM4b3JnzBndmf3UNHyzbVNfy5ZX5lZjB0JL2TCgrZmJZMX0Kk7vuTwGfiIiItGrpqSmc1qeA0/oU8OPzy5i/bntd8PeLlxbwi5cW0Kugbd1OHyd070BqSnIFf+b+DxtYtErDhw/3Dz/8sMmfk4jNGEVERBLV2q27mVJeweR5lbzzyQb2Vzsd22YwdmDU769fIW0yUgF4ZsZq7p60gM+VbOexlbl876wBXDysaXZ2NbPp7j68SW5eD2X4REREJGF1zmvDNSN6cs2Inmzfs5/Xon5/k+au44npq8hMS+GMfgUU5GTyzIzV7KmqgRJYvWU3Nz01G6DJgr7mpIBPREREkkJuVjrnD+7C+YO7sL+6hveXHqj7W72lsu68mRvDdO/u/dXcPWlBQgR8alwjIiIiSSc9NYXT+xZw24XH8eYPxvyf99bsOlDft2bL7uYeWpNQwCciIiJJzczo2r5N3euzutXUfd0l5nhrpoBPREREkt73zhpAm/SweCM1SvC1SU/le2cNiOOoGo9q+ERERCTp1dbp3T1pAbCdru3bNOkq3eamgE9ERESEEPRdPKwr06ZN458/Pzrew2lUmtIVERERSXAK+EREREQSnAI+ERERkQSngE9EREQkwSngExEREUlwCvhEREREEpwCPhEREZEEp4BPREREJMGZu8d7DI3CzNYDy5vhUQXAhmZ4joiIiMRHc/yu7+HuhU38jDoJE/A1FzP70N2Hx3scIiIi0jQS8Xe9pnRFREREEpwCPhEREZEEp4Dv6N0f7wGIiIhIk0q43/Wq4RMRERFJcMrwiYiIiCQ4BXzNzMws3mMQERGR5KKAr5m55tBFRETkGJhZppm1OZZrFfA1MTNLOeh1qZndWt97IiIiIvUxswzgNuBmMzv1aK9XwNFEzKyPmXVz95qD3toBXGtm7et5T0RERKSOmeWYWRt33wfcCXwE3G1mPY/mPgr4ms51wIMAZvYjM5toZh3cfSXwElAa19GJiIhIi2ZmXYGLgAIz6w0UuPuTwOvA183spIbeSwFfIzpoivZeoK2ZDQfKgXOAn0fv9QZ2RddoEYeIiIjUqY0n3H01cAbwF+AVoG90ym+iz2eYWU5D7qmAr5GYWUrsFK27rydk+O5292fc/Uagv5ldBbQFJkTnaRGHiIiIxAZ6sSVfa4FOwI3uPjV6vxJ4D+gJtG/IvRXwfUq1GTp3rzGzfmb232b2JTPLdPcHgL1m9t3o9OuAdKAMyIm9XkRERJJbbaBnZmPN7F4zG0OYMbwHONHM+sec/ndgENAluuaw8YQCvmMUE+i5maWY2TnAfUAFcAHw++jUe4BrzKyjuy929z8CdwOn1F7f/KMXERGRluDgQM3MbgZ+CmwAvk4oB/tfQjnY4OicbHffA7wAXAxHjie0tdpRitKtHvuDNbMvEP5Qnnf3u8ysHbAcGOvuM8zsASDD3b8Qnd8TvXrrAAAO7klEQVQGeBK4wt23N/93ISIiIvFiZlZfgBbFGL8G/uju080sFVgNnE2o3xtLyOgZcA0wEkhz9+eO9Exl+I6Su9dEWb3TzezrZtYNeBiYCaSbWaG7bwN+Rcj4QUjHupm1iYLB/wLWADvj8T2IiIhIXH1sZucBmNl1ZvZvZtYXcGAEkAfg7tXAbwklYU8CjwOzgK9HscYyYHpDHqgM31GKou27gdOBd4EhhNUyy4FvAb9z9zeic/cAV7r70wdd38fdFzb32EVERCR+zCzV3avN7Drgh4R44lxCEig7en0i8C13PyG65kfAWnd/8KB71ZslPOSzFfAdHTPLBv4D+JG7rzWzscCfCSnW24G9wMPuvszMSt19Xsy1qVG0LiIiIknMzF4DUt19ZLSLxleBwe7+NTN7hrAmoCPQC/iGu7/7aZ6nKd16RIswDrXapTswHNgStWJ5hZBO/TyhT84JHFgiPT+6X+0CDwV7IiIiSaK+LVSjmT6AG4FTzSw32kXjHaDazC4DLgEeIPTeO+nTBnugDN8/iE2RmlmBu284+D0zewmY6e4/jI7fA7zo7q9E26mtis/oRUREJN5iO3kcdDw1OlzbfuVRoMbdPx/NIF5GWHX7dXeviLnu//T6PaYxKeALYqdbo1W09xK6W/8amOzuy80sw933mVl3Qv+bRwip1iHANe4+P07DFxERkRbGzIYQMnnPAB+7+5Lo+CCgK/AmYeHFWe7+kZn1AFLcfWljjyXpp3QPnm41s8GEVOpiQquV44Cro3P2mVmau68AriIs1FgOnKZgT0REJHnV00/va4SuHC8QFmI8FB2/l1AC1tbdd0bH7wZw9+VNEewBpDXFTVuD2unZmOnbEcAvge1AKWF17VtmlgtcbGbjoi1NHMDdZxGWRtfeTwsyREREkszB8UTtMcKOWucTeuedBUyO3n4OuNnddwG4+7ejRRtNKmkzfAf9wXyOMIV7u7ufBSwFxkRvTycsvvhM1Nn6H4K66A9bwZ6IiEgSOaju/xwz+4mZFUfHzgFmE9quXO/u/2pmRe4+zd13mVmaRaIZxCaNyZIq4ItNt0Y/41vNLJ8wfZsJlERvfxv4kpl1jzYongnsAbrVd19tjyYiIpJ8ooWcJWb2A+CbQBnw06h273bCLhhfdveZZtYbuNPMhkXXVsVmBj/toowjSepFG2b2GLDb3b9kZv8C9ATucvf1ZnY/UOjul0Sp1hp3r4rneEVERCR+6ivfMrMHgdPdvX/0+iYgF7gD+B2hfG4vMJSwOcNvm3fUQUJn+KIsXkr0dYqZ9TSzO8ysODrlm8DpUbT9FOHncWn03g+A7dGK3f3uXnWY3nwiIiKS4GIWeE4ws5Oiw78FOppZafT6HcKuGRMI+93eCbwHnBGvYA8SOMMX27PGzNq5+zYzyyI0Mfx34K9REHcjcLa7n2Vm1wIXAje5+6L4jV5ERETiKUrylALd3P3l6FgPwu5a2wm7YDwN/BH4EjDU3S+Peu3VTu/e5e7LYu75qfvpHauEzfC5e02U1bsTeM3MbiCssL2TsCtGbT3eVOB4M7uCkOX799hgr6mLKEVERKTliWrrugBfjDk8EZju7ucA3wDaEWYG/wB0MbPzoyzgS8BvYoO96J5xCfYggQM+MzsTeBzYRpieHQ7c4O4vAuuBa8ysAzAAeA0oc/cd7v5a7H3i+YcjIiIicbUVmBfFCwAG5AO4+wfAEmCAu68BngS+G703z93nxGG8h5SwAR/hD+QzhKnblwl9b3qb2cmEQsp8QqD3BeB77n5r3EYqIiIicXWIOv3dwChgf/S6AlhhZqOi1+8CA8wsnVDLd3GTD/QYJWzA5+5PA38j7JYBIbhbQUi9bnH3fwGucvfza/e+1fStiIhIcjGzPDMbWF+LtShLtxf4cXToI2AD8DMz+yxh+9W3wqle7e5bWmoskbCLNqBuD7uHgUvdfaGZTSQ0QHww2imj9jztkiEiIpKEzKwEeIKQEPoq8Ji7z6tdYGFmfQmBXpm7rzKzNOAK4ARgvrs/ELfBH4WEDvgAokUbw9z9vCjqbhPtXSciIiJJKCaYq/08i9CL9yfAfe6+Lzov1d2rzewXQGfClmjLo/did9mw+jKELUmLTDs2sv8ANtcWXLr7TvXTExERST61/XljFmSmm1lb4K+EBRl/jLY5S4/erz3vh4QFGt82s3OhbpcNq/26+b6LY5PwGT4RERGRWGZ2PPBTYBHwhLu/ZWY/Bs5y99MPOjct6tubBpwKnAn82t13NfvAP4WkCfji2exQRERE4uPgOn0zuwa4AfhXoDtwE3Ceuy8ys5XAF919qpmd6e6v13O/THff21zjbyzJMKULqJ+eiIhIMorZDm1ctAvGZMKuWrnA14A9wPXR6d8GfmVmcwnZvPru1+qCPQgb+oqIiIgkJDMbCfwcWA0siFbankDI8p1H2Pd2lplNc/e/mtkSYJO7L43fqBtf0mT4REREJCldB/yvu19e23eXEORluvtGwmKN9YRtVjPdfbq7L22p/fSOlTJ8IiIikpDMrBdhZ63nohW1me6+B9gEzDWz1wmx0I/d/S+x1yZaKVjSLNoQERGRxGJmXwY6Ar9z9y2HOGc2cIu7PxNzrIQQ9F0GPOvum6PjLb6f3rFKqHSliIiIJD4zyzSz+4EvAm9zoF9e7Dm1vfRuJmyFdr6ZjTWzt4CJ7r7T3f/g7ptrp28TNdgDTemKiIhI69OesNXZyNiDZpYLnObuk9x9P4C7P2tmxYT+eScC/+XuD8del2jTt/XRlK6IiIi0Omb2JrCQsPfty9GxS4AhwF1ANRw6mEvk6dv6KOATERGRViNm/9si4G+EwG4H8BowCFjs7rfUc51F26El5UYMmtIVERGRFql2l4zYbFwU7KUCm4HngKeATKAfcD5wmpl1Au539w9q7xV7fXN/Hy2BAj4RERFpkaJgrx0hXtkEdZm62uPnA6+5+5vATDMbASwFZsUGe6JVuiIiItJCHNzs2MyuAuYA/2lmV0DI1EWZv83A08APzOxxM5sD7Abuq28P3GSnGj4RERGJu9hpWzMbBaQDpwN/iD6fCTzh7lPMLM3dq6JzOwNjgLfdfdnB95JAAZ+IiIjEzUGBXmfgB8AoYCtQ5e7jo+NXAl2Bm919d5QN9NjALlkXZDSEpnRFREQkbmKCve7AL4Fu7j4M+Cegt5l1cfe1wLtAFnB1dF3NwVk8BXuHpoBPREREmk09dXqjzOzf3X0F8DFQZGYF7l4OvALcGZ36MTAb2N6sA04QmtIVERGRZldbhxe1UJlOWHFbAfwQKHf3/zazPGARcKW7TzWzDHffF8dht1rK8ImIiEiTivrm1WX3zOxW4GozS3f3dYSp3HvcfQ3wHjDUzAa5+1bCXrh7ABTsHTsFfCIiItIkagO9qG9eClAYvbUEuJSwCAN3vxfoEG2N9izgwEXRe/e7+1vNPfZEo4BPREREmoS7VwOY2YWEfnp/NLNz3P0hQiPlS80sOzr9A+BeYCdwH/DrOAw5YWmnDREREWkS0W4Y9xO2QbsIGAdcZGYbgZ8BvwUWRq/XE/bDLXb3udH16qfXSBTwiYiISFPZARQAue6+yMy2ALnAxcAtwAPAJYTGyt9y95diL1aw13i0SldERESajJkNBR4HznH3T6JdND4DzHT3B82sjbvvjjlfWb0moBo+ERERaTLuPhP4K3BHdOgtYDlQHS3q2AMHVvAq2GsayvCJiIhIkzKzIkIT5Zvd/Rkzy3b3XfEeVzJRhk9ERESalLtXAr8A9kevFew1M2X4RERERBKcMnwiIiIiCU4Bn4iIiEiCU8AnIiIikuAU8ImIiIgkOAV8IiKtmJndZmYPx3scItKyKeATkbgxs2VmttvMdsR8dGmEe45vrDGKiCQCBXwiEm8XuHtOzMeaeA7GzLTHuIgkHAV8ItLimFmemf3ezNaa2WozuzPaggkz62Nmr5jZRjPbYGZ/NrP20XsPAd2Bv0XZwu+b2WgzW3XQ/euygNGU6BNm9rCZbQO+eITn9zWz18xsa/T8vxziezjSc082sw/NbJuZVZjZvTHnnWpmb5vZFjObZWajY97rFT1/u5lNJmxMLyJyWAr4RKQl+iNQBfQFhgETgeui9wz4KdAFKAVKgNsA3P0aYAUHsoa/aODzLgKeANoDfz7C8+8AXgY6AN2Afz/G7/E3wG/cvR3Qh7C5PGbWFXgBuBPoCHwXeNLMCqPrHgGmEwK9O4AvHOPzRSSJKOATkXh7JspkbTGzZ8ysGDgH+Bd33xltyfQr4HMA7r7Y3Se7+153Xw/cC4z6lGN4x92fcfcaoN3hnk/YGqoH0MXd97j7m8f4zP1AXzMrcPcd7v5udPxq4EV3f9Hda9x9MvAhcK6ZdQdOAm6Jvv/Xgb8d4/NFJIko4BOReLvY3dtHHxcTgql0YG1tIAj8D1AEYRN2M3ssmmrdBjzMp5/WXBnz9WGfD3yfkGV838zmmtmXj/GZXwH6A/PN7AMzOz/m+ZfFBMFbgJFAZ0JWc7O774y5z/JjfL6IJBEVJ4tIS7MS2AsUuHtVPe//FHBgsLtvNLOLgfti3j94g/CdQHbti6gWr/Cgc2KvOezz3X0d8NXoXiOBKWb2ursvPprnuvsi4EozSwE+AzxhZvnR8x9y968e/Gwz6wF0MLO2MUFf93q+ZxGR/0MZPhFpUdx9LaFG7pdm1s7MUqKFGrXTtrnADmBLVO/2vYNuUQH0jnm9EMgys/PMLB24Gcg81ueb2WVm1i06fTMh2Kqu51aHfa6ZXW1mhdE08pbocDUhY3mBmZ1lZqlmlhUtAOnm7ssJ07s/MbOMKOC84FDfi4hILQV8ItISXQtkAOWEoOoJwpQmwE+AE4CthMUNTx107U+Bm6Pp0O+6+1bgn4DfAasJmbdVHN7hnn8S8J6Z7QCeA77l7ksPvkEDnns2MDe6z2+Az0U1gSsJi0h+BKwnZPy+x4H/X18FnAJsAm4F/nSE70VEBHPXTICIiIhIIlOGT0RERCTBKeATERERSXAK+EREREQSnAI+ERERkQSngE9EREQkwSngExEREUlwCvhEREREEpwCPhEREZEEp4BPREREJMH9f9K2SYbz+8A7AAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 720x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "models = list(models_scores.keys())\n",
    "train_scores = [models_scores[model][\"train\"] for model in models]\n",
    "test_scores = [models_scores[model][\"test\"] for model in models]\n",
    "\n",
    "plt.figure(figsize=(10, 5))\n",
    "plt.plot(train_scores)\n",
    "plt.plot(test_scores)\n",
    "plt.scatter(range(len(models)), train_scores, label=\"train\")\n",
    "plt.scatter(range(len(models)), test_scores, label=\"test\")\n",
    "plt.xticks(range(len(models)), models, rotation=30)\n",
    "plt.xlabel(\"Features used\", fontdict={\"size\" : 12})\n",
    "plt.ylabel(\"Model's MAE score\", fontdict={\"size\" : 12})\n",
    "plt.title(\"Dependence of model's score on the features used\", fontdict={\"size\" : 14})\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "w9-PEr8QWkyC",
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "36bec9522a440ff54b8d87534ed41320",
     "grade": false,
     "grade_id": "cell-a5cb5f37ad4de405",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "---\n",
    "## Problem 2. Text data analysis <a class=\"anchor\" id=\"problem2\"></a>\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {
    "id": "WqUtBM9TWkyC"
   },
   "outputs": [],
   "source": [
    "\n",
    "from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "FmRn3nSmWkyC"
   },
   "source": [
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "jMe0cbA7WkyC"
   },
   "source": [
    "In this part, we will solve the problem of prediction price of the wine based on text description of its characteristics. When working with text features, you have to first transform them into a vector form (vectorize) so that the model can process them. We wil consider two vectorization methods, \n",
    "* **Bag-of-Words** \n",
    "* **Tf-Idf**.\n",
    "\n",
    "Let us read the data:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {
    "id": "b11-5tr8WkyD"
   },
   "outputs": [],
   "source": [
    "df = pd.read_csv(\"winemag-data_first50k.csv\", index_col=0)\n",
    "# drop rows with unknown price\n",
    "df = df.loc[df[\"price\"].notnull()]\n",
    "\n",
    "y = df[\"price\"]\n",
    "X = df.drop([\"price\"], axis=1)\n",
    "\n",
    "X_tr, X_te, y_tr, y_te = train_test_split(X, y, test_size=0.3, random_state=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "xKyKy2uYWkyD"
   },
   "source": [
    "### Bag-of-Words vectorization\n",
    "\n",
    "Bag-of-Words is one of the most obvious and straight-forward for the text descriptions vectorization.\n",
    "In this case, we just create a feature column for each word appearing in the texts of the dataset. If the particular word is presented in the text description of a particular object, the value of the corresponding feature will be equal to 1, else - equal to 0. It is also possible to set the value of the feature to the number of times that the corresponding word has appeared in the object description.\n",
    "\n",
    "In `sklearn`, you can obtain bag-of-words vector representation of the text using the `CountVectorizer` transformer. Note, that in this case value of the resulting features will be equal to the number of times the corresponding word appeared in the object description text."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "zy5tOJmIWkyD"
   },
   "source": [
    "---\n",
    "**Task 2.1** [2 pts]  <a class=\"anchor\" id=\"task2_1\"></a>\n",
    "\n",
    "Before vectorization, we need to prepare text descriptions. Write a function to clear the text from all non-alphabetic characters and convert it to lowercase. \n",
    "\n",
    "**Hint**\n",
    "- `.lower()` method is used to conver any string to the lower case. E.g `'Hello'.lower()` retuns `'hello'`\n",
    "- Use `re.sub()` to replace all non-alphabetic characteer with empty string. You cen read more about it in the [documentation](https://docs.python.org/3/library/re.html)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {
    "deletable": false,
    "id": "a6B52gVAWkyD",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "e42b78d3bf400ce404c166bb937a938e",
     "grade": false,
     "grade_id": "cell-25e2882c43cf7177",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "import re\n",
    "def prepare_text(text):\n",
    "    \"\"\"\n",
    "    Converts the text to lowercase and removes all the non-alphabetic characters\n",
    "    (the cleared text should contain only letters from a to z and space symbols).\n",
    "    \"\"\"\n",
    "    # your code here\n",
    "    lower_text = text.lower()\n",
    "    cleared_text = re.sub('[^a-z\\s]', '', lower_text)\n",
    "    return cleared_text"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "W6Bl5EqtWkyD",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "46b3d113609a914dd769005a43d77bff",
     "grade": true,
     "grade_id": "cell-491389d3bcfc9e80",
     "locked": true,
     "points": 2,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "### TEST prepare_text\n",
    "processed = prepare_text('CLEAR it!!!')\n",
    "assert 'clear it' == processed\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "e74791f161519220b7b61dc0123d08e4",
     "grade": false,
     "grade_id": "cell-5ae370e13c04fedc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "---\n",
    "**Task 2.2** [1 pt]  <a class=\"anchor\" id=\"task2_2\"></a>\n",
    "\n",
    "Apply `prepare_text` function to the `description` feature column in the datasets `X_tr` and `X_te`. \n",
    "\n",
    "**Hint** Use the method `apply`from [pandas](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {
    "deletable": false,
    "id": "AD0_XhF9WkyD",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "65e2970aa5dffca029c5f592e6837f79",
     "grade": false,
     "grade_id": "cell-2123ec0210d09ca6",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# your code here\n",
    "X_tr['description']=X_tr['description'].apply(prepare_text)\n",
    "X_te['description']=X_te['description'].apply(prepare_text)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "0497b2570a4d8543415b98f276761aca",
     "grade": true,
     "grade_id": "cell-b100f9b1b744ac8f",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "this tremendous  varietal wine hails from oakville and was aged over three years in oak juicy redcherry fruit and a compelling hint of caramel greet the palate framed by elegant fine tannins and a subtle minty tone in the background balanced and rewarding from start to finish it has years ahead of it to develop further nuance enjoy \n"
     ]
    }
   ],
   "source": [
    "# make sure that this string does not contain upper case letter and non-alphabetical characters\n",
    "print(X_tr[\"description\"][0])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "**Task 2.3** [1 pt]  <a class=\"anchor\" id=\"task2_3\"></a>\n",
    "\n",
    "Perform the **Bag-of-Words vectorization** of the texts in `description` column, train the linear regression model on the obtained numerical features and evaluate its mean absolute error on the test set.\n",
    "\n",
    "- Use `CountVectorizer` from sklearn to perform Bag-of-Words vectorization. \n",
    "    - Use the argument `min_df=0.001` to remove the words which appear in less then 0.1% of the documents\n",
    "    - Read more about it the [documentation](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html)\n",
    "- Fit the vectorizer using descriptions from the train dataset\n",
    "- Create `textfeats_tr` which contains transformed descriptions from the train dataset\n",
    "- Create `textfeats_te` which contains transformed descriptions from the test dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {
    "deletable": false,
    "id": "ynyw-HBeWkyD",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "1ea64cff7380642e7626de42dfa994dd",
     "grade": false,
     "grade_id": "cell-6261a8396767b246",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "bow_vectorizer = CountVectorizer(min_df=0.001)\n",
    "# your code here\n",
    "bow_vectorizer.fit(X_tr['description'])\n",
    "textfeats_tr = bow_vectorizer.fit_transform(X_tr['description'])\n",
    "textfeats_te = bow_vectorizer.fit_transform(X_te['description'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {
    "deletable": false,
    "editable": false,
    "id": "xvAb-SeTWkyD",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "188ddb6ce2b3d0632c6ed3824125ff4e",
     "grade": true,
     "grade_id": "cell-4ae5c84cf3158079",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(31801, 2468)\n",
      "(13630, 2517)\n"
     ]
    }
   ],
   "source": [
    "### TEST bag-of-words vectorization\n",
    "print(textfeats_tr.shape)\n",
    "print(textfeats_te.shape)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Train and evaluate a `LinearRegression` model on the obtained features. We will use function `evaluate_model`, that you've created in the previous part."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {
    "id": "hD1810BBWkyD",
    "outputId": "f89fc250-d343-4d71-ad42-bc57fdde35ad"
   },
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-89-e73d820584f9>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0mmodel\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mLinearRegression\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m mae_tr, mae_te = evaluate_model(model, textfeats_tr, y_tr, \n\u001b[0;32m----> 3\u001b[0;31m                                 textfeats_te, y_te)\n\u001b[0m\u001b[1;32m      4\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Train MAE = %.3f\"\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mmae_tr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Test MAE = %.3f\"\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mmae_te\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-22-0fbbab906bd0>\u001b[0m in \u001b[0;36mevaluate_model\u001b[0;34m(model, X_tr, y_tr, X_te, y_te)\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mevaluate_model\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmodel\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_te\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_te\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m     \u001b[0;31m# your code here\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 5\u001b[0;31m     \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_tr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_tr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      6\u001b[0m     \u001b[0;31m#model.fit(X_te, y_te)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      7\u001b[0m     \u001b[0my_pred_te\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpredict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_te\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/sklearn/linear_model/_base.py\u001b[0m in \u001b[0;36mfit\u001b[0;34m(self, X, y, sample_weight)\u001b[0m\n\u001b[1;32m    519\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    520\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndim\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0;36m2\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 521\u001b[0;31m                 \u001b[0mout\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0msparse_lsqr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_centered\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    522\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcoef_\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mout\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    523\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_residues\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mout\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m3\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/scipy/sparse/linalg/isolve/lsqr.py\u001b[0m in \u001b[0;36mlsqr\u001b[0;34m(A, b, damp, atol, btol, conlim, iter_lim, show, calc_var, x0)\u001b[0m\n\u001b[1;32m    417\u001b[0m         \u001b[0;34m%\u001b[0m                \u001b[0malfa\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mv\u001b[0m  \u001b[0;34m=\u001b[0m  \u001b[0mA\u001b[0m\u001b[0;31m'\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mu\u001b[0m  \u001b[0;34m-\u001b[0m  \u001b[0mbeta\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mv\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    418\u001b[0m         \"\"\"\n\u001b[0;32m--> 419\u001b[0;31m         \u001b[0mu\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mA\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmatvec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mv\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0malfa\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mu\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    420\u001b[0m         \u001b[0mbeta\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlinalg\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnorm\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    421\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/scipy/sparse/linalg/interface.py\u001b[0m in \u001b[0;36mmatvec\u001b[0;34m(self, x)\u001b[0m\n\u001b[1;32m    227\u001b[0m             \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'dimension mismatch'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    228\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 229\u001b[0;31m         \u001b[0my\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_matvec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    230\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    231\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmatrix\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/scipy/sparse/linalg/interface.py\u001b[0m in \u001b[0;36m_matvec\u001b[0;34m(self, x)\u001b[0m\n\u001b[1;32m    525\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    526\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_matvec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 527\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__matvec_impl\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    528\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    529\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_rmatvec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/sklearn/linear_model/_base.py\u001b[0m in \u001b[0;36mmatvec\u001b[0;34m(b)\u001b[0m\n\u001b[1;32m    509\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    510\u001b[0m             \u001b[0;32mdef\u001b[0m \u001b[0mmatvec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 511\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mb\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_offset_scale\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    512\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    513\u001b[0m             \u001b[0;32mdef\u001b[0m \u001b[0mrmatvec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/scipy/sparse/base.py\u001b[0m in \u001b[0;36mdot\u001b[0;34m(self, other)\u001b[0m\n\u001b[1;32m    361\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    362\u001b[0m         \"\"\"\n\u001b[0;32m--> 363\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mother\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    364\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    365\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mpower\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mn\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/scipy/sparse/base.py\u001b[0m in \u001b[0;36m__mul__\u001b[0;34m(self, other)\u001b[0m\n\u001b[1;32m    469\u001b[0m             \u001b[0;31m# Fast path for the most common case\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    470\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mother\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mN\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 471\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_mul_vector\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mother\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    472\u001b[0m             \u001b[0;32melif\u001b[0m \u001b[0mother\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mN\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    473\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_mul_vector\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mother\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mravel\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreshape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mM\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/opt/conda/lib/python3.7/site-packages/scipy/sparse/compressed.py\u001b[0m in \u001b[0;36m_mul_vector\u001b[0;34m(self, other)\u001b[0m\n\u001b[1;32m    471\u001b[0m         \u001b[0;31m# csr_matvec or csc_matvec\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    472\u001b[0m         \u001b[0mfn\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgetattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0m_sparsetools\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m'_matvec'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 473\u001b[0;31m         \u001b[0mfn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mM\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mN\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mindptr\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mindices\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mother\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mresult\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    474\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    475\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mresult\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "model = LinearRegression()\n",
    "mae_tr, mae_te = evaluate_model(model, textfeats_tr, y_tr, \n",
    "                                textfeats_te, y_te)\n",
    "print(\"Train MAE = %.3f\" % mae_tr)\n",
    "print(\"Test MAE = %.3f\" % mae_te)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "vppR-f07WkyD"
   },
   "source": [
    "### Tf-Idf vectorization\n",
    "\n",
    "Another way to deal with text data is TF-IDF - Term Frequency - Inverse Document Frequency vectorization. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "pLMvt3B2WkyD"
   },
   "source": [
    "---\n",
    "**Task 2.4** [1 pts]  <a class=\"anchor\" id=\"task2_4\"></a>\n",
    "\n",
    "Perform **Tf-Idf vectorization** of the cleaned description obtained in the previous step. \n",
    "\n",
    "\n",
    "- Use `TfidfVectorizer` from sklearn to perform Bag-of-Words vectorization. \n",
    "    - Use the argument `min_df=0.001` to remove the words which appear in less then 0.1% of the documents\n",
    "    - Read more about it the [documentation](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html)\n",
    "- Fit the vectorizer using descriptions from the train dataset\n",
    "- Create `textfeats_tr` which contains transformed descriptions from the train dataset\n",
    "- Create `textfeats_te` which contains transformed descriptions from the test dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {
    "deletable": false,
    "id": "h8VQRr9mWkyD",
    "nbgrader": {
     "cell_type": "code",
     "checksum": "dc84671aed08f5d909931e4cfa4d7276",
     "grade": false,
     "grade_id": "cell-1253b9f2b4143df7",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "tfidf_vectorizer = TfidfVectorizer(min_df=0.001)\n",
    "# your code here\n",
    "textfeats_tr = tfidf_vectorizer.fit_transform(X_tr['description'])\n",
    "textfeats_te = tfidf_vectorizer.fit_transform(X_te['description'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "5a0ef87a3e11ee0ee282f406c9128111",
     "grade": true,
     "grade_id": "cell-5ce6a8403c6f1cb0",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(31801, 2468)\n",
      "(13630, 2517)\n"
     ]
    }
   ],
   "source": [
    "### TEST bag-of-words vectorization\n",
    "print(textfeats_tr.shape)\n",
    "print(textfeats_te.shape)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again, we need to train and evaluate the linear regression model on the vectorized text features."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "nKwaDhPoWkyD",
    "outputId": "1e6b5f29-7cb4-4fd6-836c-513c9d307802"
   },
   "outputs": [],
   "source": [
    "model = LinearRegression()\n",
    "mae_tr, mae_te = evaluate_model(model, textfeats_tr, y_tr, \n",
    "                                textfeats_te, y_te)\n",
    "print(\"Train MAE = %.3f\" % mae_tr)\n",
    "print(\"Test MAE = %.3f\" % mae_te)"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "authorship_tag": "ABX9TyMQRY7nzsLHW7b9DxofAant",
   "collapsed_sections": [
    "xKyKy2uYWkyD",
    "zy5tOJmIWkyD",
    "vppR-f07WkyD"
   ],
   "name": "HW 1",
   "provenance": [
    {
     "file_id": "1wzx_Qny7A-fXUqfiWgn6q5qZJ3zAueKM",
     "timestamp": 1607432099194
    }
   ]
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
